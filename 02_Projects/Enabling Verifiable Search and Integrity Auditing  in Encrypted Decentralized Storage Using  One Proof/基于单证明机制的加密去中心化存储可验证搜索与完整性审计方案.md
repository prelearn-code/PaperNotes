
## 1. 引言

随着Web 3.0时代的到来，数据的存储范式正经历着从中心化云存储（Centralized Cloud Storage, CCS）向去中心化存储网络（Decentralized Storage Networks, DSNs）的深刻变革。在诸如Amazon AWS或Microsoft Azure等传统架构中，用户被迫将数据的控制权让渡给单一的服务提供商，这不仅带来了单点故障的风险，还引发了关于数据主权、隐私泄露及审查制度的广泛担忧。相比之下，DSN（如Filecoin, Sia, Storj等）利用区块链技术构建了一个公平、透明且无需许可的存储市场，允许网络边缘的独立设备（即存储节点）通过出租闲置的硬盘空间来获取经济激励 1。

然而，DSN的自治性与开放性是一把双刃剑。由于缺乏中心化的信誉背书，DSN中的存储节点往往被视为“不可信”或“半诚实”的实体。为了保障数据隐私，用户必须在数据外包前对其进行加密。这一加密需求与数据可用性之间产生了天然的矛盾：如何在不解密的前提下对数据进行检索（即密文搜索）？更进一步地，由于存储节点可能为了节省计算资源或通信带宽而返回不完整、甚至错误的搜索结果，用户如何验证检索结果的正确性（Verifiability）？与此同时，节点可能因硬件故障或恶意行为丢失数据，因此定期的完整性审计（Integrity Auditing）对于确保存储服务的可靠性至关重要 1。

当前的学术研究与工程实践在解决上述问题时，往往陷入了“功能割裂”的困境。现有的方案要么专注于完整性审计以优化链上存储成本，要么专注于可验证搜索但依赖于违背去中心化原则的第三方“仲裁者”（Arbiter）1。若简单地将两者叠加，会导致存储节点需要生成两份独立的证明，并由区块链执行两次验证，这在计算资源受限且链上存储空间昂贵（Gas Fee）的区块链环境中是不可接受的 1。

本报告基于Mingyang Song等人于2025年在《IEEE Transactions on Computers》上发表的顶刊论文《Enabling Verifiable Search and Integrity Auditing in Encrypted Decentralized Storage Using One Proof》，对其中提出的“单证明”（One Proof）方案进行详尽的深度剖析。该方案通过一种新颖的密码学结构，将可验证搜索与完整性审计统一在同一个证明体系中，实现了在不显著增加链上开销的前提下，同时保障数据检索的正确性与数据存储的完整性。本报告将严格遵循论文背景、相关工作、方案实现细节及效果分析的框架，展开全方位的技术解读。

## 2. 研究背景与基础理论

### 2.1 去中心化存储网络（DSN）的运行机理

DSN的核心经济模型是“存储证明”（Proofs-of-Storage, PoS）。与比特币的“工作量证明”（PoW）不同，DSN要求矿工（存储节点）证明其确实存储了客户的数据副本。

- **市场机制**：客户发布存储订单，节点竞标。一旦达成协议，数据被加密并分片存储。
- **信任缺失**：由于节点不仅是服务提供者，也是追求利益最大化的理性经济人，其存在“理性作恶”的动机。例如，当客户发起检索请求时，如果检索涉及大量文件，节点可能只返回部分结果以节省带宽（Lazy Search）；或者节点可能已经删除了部分冷数据，却通过伪造证明试图骗取存储费 1。
- **链上瓶颈**：所有验证逻辑通常由部署在区块链（如Ethereum）上的智能合约执行。智能合约的执行成本（Gas）与计算复杂度和数据存储量成正比。因此，任何安全方案的设计首要原则必须是最小化链上开销 1。
    
### 2.2 密文搜索与可验证性的挑战
在加密数据上进行搜索通常采用可搜索加密（Searchable Encryption, SE）技术。然而，在DSN场景下，SE面临特殊的挑战：
- **结果验证（Result Verification）**：传统的SE方案假设服务器是诚实的，会返回所有匹配结果。但在DSN中，客户需要密码学证据证明“没有文件被遗漏”（Completeness）且“返回的文件未被篡改”（Correctness）。
- **前向安全性（Forward Security）**：考虑到DSN支持动态数据更新，新插入的文件不应泄露其与历史搜索查询的关联。如果缺乏前向安全性，攻击者（存储节点）可以通过分析新文件与旧搜索令牌（Search Token）的匹配情况，推断出新文件的关键词信息 1。
    

### 2.3 密码学基础：双线性对与困难假设

本方案的数学基石是复合阶群上的双线性对（Bilinear Pairing of Composite Order）。

- **定义**：设 $\mathbb{G}_1$ 和 $\mathbb{G}_2$ 是阶为 $N=pq$ 的循环群，$e: \mathbb{G}_1 \times \mathbb{G}_1 \rightarrow \mathbb{G}_2$ 是一个双线性映射。其核心性质包括双线性（$e(u^a, v^b) = e(u, v)^{ab}$）、非退化性和可计算性 1。
- **作用**：双线性对允许验证者在不解密标签和数据的情况下，验证两个加密元素之间的乘法关系。这是实现“单证明”验证的关键，即验证者可以通过 $e(\text{聚合标签}, g) \stackrel{?}{=} e(\text{证据}, pk)$ 形式的等式，同时检查搜索结果的链接关系和数据块的完整性。
- **安全性假设**：方案的安全性依赖于计算性Diffie-Hellman（CDH）假设。简单来说，给定 $g, g^a, g^b$，在多项式时间内计算出 $g^{ab}$ 是不可行的。这意味着攻击者无法在不知道私钥的情况下伪造出合法的聚合签名 1。

## 3. 相关工作综述与差距分析

为了明确本方案的创新性，必须系统梳理现有的解决方案及其局限性。现有研究主要分为两大阵营：独立的完整性审计与独立的可验证搜索。

### 3.1 云存储中的完整性审计

数据完整性审计旨在验证远程服务器是否完好保存了数据，主要技术路线包括：
- **PDP与POR**：Ateniese等人提出的数据持有性证明（PDP）和Juels等人提出的可恢复性证明（POR）是该领域的基石。它们利用同态线性认证器（Homomorphic Linear Authenticators, HLAs）支持对数据块的聚合验证，极大地降低了通信开销 3。
- **DSN中的应用**：
    - **Merkle Tree方案**：Sia和早期的Storj采用Merkle树进行审计。虽然计算高效，但Merkle证明的大小随数据量对数长，且难以支持无限次的审计挑战。
    - **零知识证明方案**：Filecoin采用zk-SNARKs（零知识简洁非交互式知识论证）来实现时空证明（PoSt）。尽管安全性极高，但其证明生成极其耗时，且验证过程对链上资源消耗巨大。
    - **多项式承诺**：Du等人 引入了基于多项式承诺的审计方案，优化了DSN中的通信效率，但这些方案通常只关注静态数据，难以处理动态更新。
        
### 3.2 可验证可搜索加密（VSE）

为了防止云服务器返回错误结果，VSE方案应运而生：

- **传统云环境**：Kurosawa和Ohtaki 以及Fu等人 提出了多种验证机制，如利用MAC（消息认证码）链或累加器。然而，这些方案通常假设存在一个可信的第三方审计员，或者验证过程仅限于用户本地，无法实现DSN所需的“公开可验证性”（Public Verifiability）。
- **区块链辅助方案**：部分研究 尝试将整个索引数据库发布到区块链上。这种方法虽然保证了不可篡改性，但彻底暴露了访问模式，且存储成本极高，不具备可扩展性。
- **Arbiter模式**：Cai等人 提出了DSN场景下的VSE方案，但引入了一组“仲裁者”服务器来存储索引并重新执行搜索以验证结果。Song等人指出，这种架构引入了新的中心化实体，本质上违背了DSN的去中心化初衷 1。
    

### 3.3 本方案的突破点

表3-1总结了本方案与现有技术的关键差异。Song等人的核心洞察在于：搜索结果的正确性验证与文件的完整性验证在数学结构上是可以同态聚合的。通过设计一种特殊的“关键词关联标签”（Keyword-Associated Tag），可以将所有包含相同关键词的文件串联起来。此时，验证搜索结果的完整性（链条是否断裂）与验证文件内容的完整性（数据块是否受损）可以合并为一个数学验证过程，从而将链上验证开销减半 1。

**表 3-1: 现有方案与Song等人方案的对比分析**

|**特性维度**|**传统Merkle审计 (如Sia)**|**仲裁者VSE (Cai et al. )**|**多项式审计 (Du et al. )**|**本方案 (Song et al.)**|
|---|---|---|---|---|
|**主要功能**|仅完整性审计|仅可验证搜索|仅完整性审计|**搜索 + 审计 (一体化)**|
|**去中心化程度**|高|中 (依赖仲裁者)|高|**高 (无第三方)**|
|**验证方式**|概率性挑战|重执行搜索|概率性挑战|**确定性聚合验证**|
|**链上开销**|低|高|中|**低 (单证明)**|
|**动态更新支持**|有限|支持|有限|**支持 (前向安全)**|
|**前向安全性**|不适用|部分支持|不适用|**完全支持**|

## 4. 方案详细设计与实现细节

本章节将深入解构论文提出的“单证明”方案，涵盖系统实体定义、核心数据结构设计以及八大算法的具体执行流程。

### 4.1 系统实体与交互模型

系统包含三个核心实体，它们通过以太坊区块链进行交互：

1. **客户端 (Client)**：数据拥有者。负责数据的加密、索引构建、标签生成以及发起搜索和更新请求。客户端本地维护一个轻量级的状态集合 $SS$，用于记录每个关键词的最新状态。
2. **存储节点 (Storage Node)**：DSN中的矿工。负责存储密文数据、索引数据库 $DB$，并响应客户端的查询。节点需定期生成证明提交至区块链。
3. **区块链 (Blockchain)**：不可篡改的公共账本。用于存储公共参数 $PP$、搜索请求、证明数据以及执行智能合约进行自动验证（Verify.Search 和 Verify.Audit）1。
    

### 4.2 核心数据结构设计

为了实现“单证明”验证及前向安全性，方案设计了三种关键的密码学组件：

#### 4.2.1 关键词关联标签 (Keyword-Associated Tag, $kt$)

这是实现结果可验证性的核心。与传统SE方案中独立索引不同，本方案利用 $kt$ 将所有包含特定关键词 $w$ 的文件逻辑上串联起来。
- **构造逻辑**：对于关键词 $w$ 下的第 $i$ 个文件 $F_i$，其标签 $kt_i^{(w)}$ 不仅包含文件标识符 $ID_{F_i}$，还绑定了当前状态 $st_i$ 和前一个状态 $st_{i-1}$。
- 数学形式：
    $$kt^{(w_i)} =^{sk}$$
    其中，$sk$ 是客户端私钥，$T_i$ 是加密关键词。
- **作用**：这种除法结构（在指数上体现为减法）使得在聚合验证时，中间状态可以相互抵消（类似裂项相消），最终只剩下首尾状态。如果存储节点试图删除中间的某个文件，链条就会断裂，聚合验证将失败 1。

#### 4.2.2 状态关联令牌 (State-Associated Token, $\bar{T}$)

为了实现前向安全性，必须切断新插入文件与历史查询之间的联系。

- **动态状态**：每次插入包含关键词 $w$ 的新文件时，客户端都会随机选择一个新的状态 $st_{new}$。
- **令牌生成**：搜索令牌不再仅仅是关键词的哈希，而是 $\bar{T} = H_2(T || st)$。
- **作用**：由于每次状态 $st$ 都是全新的且对存储节点保密，节点无法通过历史搜索使用的令牌 $\bar{T}_{old}$ 来识别新插入的文件，从而阻断了文件注入攻击 1。
    

#### 4.2.3 状态关联指针 (State-Associated Pointer, $ptr$)

由于状态是随机更新的，存储节点需要一种机制来遍历所有相关文件。

- **构造**：$ptr^{(d-1)} = SE.Enc(H_3(st_d), st_{d-1})$。即用当前状态 $st_d$ 作为密钥，加密前一个状态 $st_{d-1}$。
- **遍历过程**：搜索时，客户端只需公开最新的状态 $st_{last}$。节点解密 $ptr^{(last)}$ 得到 $st_{last-1}$，依此类推，直到回溯到链条的起点。这形成了一个反向的加密链表 1。

### 4.3 算法流程详解

方案定义了八个多项式时间算法，涵盖了系统的全生命周期 1。

#### 4.3.1 系统初始化 (Setup & KeyGen)

- **Setup($\kappa$)**: 存储节点运行。生成双线性参数 $(p, q, N, \mathbb{G}_1, \mathbb{G}_2, e)$ 和哈希函数 $H_1, H_2, H_3$。发布公共参数 $PP$ 到区块链。
- **KeyGen($PP$)**: 客户端运行。随机选择 $sk \in \mathbb{Z}_N$ 作为主私钥，计算公钥 $pk = g^{sk}$ 并发布。
    

#### 4.3.2 数据插入 (Insert)

这是一个关键步骤，确立了前向安全性和验证链。

1. **数据加密**：客户端将文件 $F$ 加密为 $C$，并计算文件ID $ID_F = H_1(C)$。
2. **完整性标签生成**：对每个数据块 $m_i$ 生成同态认证标签 $\sigma_i =^{sk}$。
3. **索引构建**：
    - 对于文件中的每个关键词 $w$，检索其本地记录的最新状态 $st_{old}$。
    - 生成新状态 $st_{new}$。
    - 计算状态关联令牌 $\bar{T} = H_2(T || st_{new})$。
* 计算回溯指针 $ptr = Enc(st_{new}, st_{old})$。
* 计算关键词关联标签 $kt$（链接 $st_{new}$ 和 $st_{old}$）。
1. 外包：发送 $\{C, TS_F, \bar{T}, ptr, kt\}$ 给存储节点。节点将其存入索引数据库 $DB$。

#### 4.3.3 可验证搜索 (Search)

此过程不仅检索数据，还生成“单证明”。
1. **请求**：客户端发布搜索请求 $(T, st_{last})$ 到区块链。$T$ 是加密关键词，$st_{last}$ 是该关键词的最新状态。
2. **遍历与检索**：存储节点利用 $st_{last}$ 计算 $\bar{T}_{last}$，在 $DB$ 中查找对应的 $ptr$ 和 $ID_F$。解密 $ptr$ 得到前一个状态，循环执行直到链头。
3. **结果集合**：节点收集所有匹配的文件ID集合 $Res = \{ID_{F_1},..., ID_{F_d}\}$。
4. **单证明生成 (Proof Generation)**：
    - **聚合关键词标签**：$\rho = \prod_{x=1}^{d} kt_x^{(w)}$。
    - **聚合数据完整性证据**：利用同态性质，将所有被搜索文件的认证标签 $\sigma$ 聚合成 $\varphi$，将密文块聚合成 $\psi$。
    - 最终证明 $PS = (Res, \rho, \psi, \varphi)$ 发布到区块链 1。
    
#### 4.3.4 联合验证 (Verify.Search)

智能合约或第三方节点执行单次验证：
$$e(\zeta_3, g) \stackrel{?}{=} e(\zeta_1 \cdot \zeta_2 \cdot H_2(st_d |

| T) \cdot \mu^{\rho}, pk)$$
- **原理**：等式左边代表了基于返回的聚合标签计算出的“承诺”。等式右边利用公钥 $pk$ 和公开参数，重构了“应该存在”的结构。
- **双重保障**：如果 $Res$ 中缺少任何一个文件，或者任何一个文件的内容被篡改（导致 $\psi$ 变化），双线性对的等式将无法配平。这意味着单一的验证步骤同时覆盖了搜索结果的完备性（Completeness）和文件内容的完整性（Integrity）1。
    

#### 4.3.5 审计 (Audit)

对于未被搜索的文件，系统回退到标准的完整性审计模式，节点生成常规的完整性证明，验证逻辑与搜索验证类似，只是缺少了关键词标签的聚合部分。

## 5. 安全性分析

论文在随机预言机模型（Random Oracle Model）下提供了严格的安全性证明。

### 5.1 关键词隐私 (IND-CKA)

方案满足“选择关键词攻击下的不可区分性”（IND-CKA）。在安全游戏中，攻击者（恶意存储节点）即使能观察到密文和索引，也无法区分两个加密关键词对应的内容。这是因为搜索令牌 $T$ 是由客户端私钥 $mk$ 加密的，且索引中的 $\bar{T}$ 混入了随机状态 $st$，使得密文分布看起来是随机的 2。

### 5.2 前向安全性 (Forward Security)

这是本方案的一大亮点。假设攻击者攻陷了存储节点，获取了所有历史数据和当前的搜索请求。
- **攻击路径阻断**：攻击者试图判断新插入的文件 $F_{new}$ 是否包含关键词 $w$。然而，索引中存储的是 $H_2(T || st_{new})$。由于 $st_{new}$ 是客户端新生成的随机数，且仅由客户端持有，攻击者无法从历史的搜索令牌（基于 $st_{old}$）推导出新的哈希值。
- **单向性**：指针 $ptr$ 是用新状态加密旧状态，因此只能回溯，不能前推。这确保了新数据的隐私不会因旧查询而泄露 1。
    

### 5.3 搜索结果与数据完整性的可验证性

安全性归约于CDH困难假设。
- **防伪造**：若节点试图伪造证明（例如，声称拥有文件但实际已删除），它需要构造一个 $\psi'$ 和 $\varphi'$ 满足双线性等式。这在数学上等价于解决计算性Diffie-Hellman问题。由于在多项式时间内CDH问题被认为是不可解的，因此节点无法伪造合法的证明。
- **防篡改**：由于关键词标签 $kt$ 形成了连锁反应，任何中间环节的缺失都会导致聚合值 $\rho$ 发生不可预测的变化，从而无法通过 $e(\dots, pk)$ 的验证。
    

## 6. 性能评估与实验分析

为了验证方案的实用性，作者基于C++实现了原型系统，使用了PBC库（Pairing-Based Cryptography）和OpenSSL库，并在以太坊测试网上部署了智能合约进行Gas开销评估。

### 6.1 实验设置

- **数据集**：采用了Enron邮件数据集生成的三个子集（DB1, DB2, DB3），文件数量从4,108到55,064不等，旨在模拟不同规模的DSN负载 1。
- **硬件环境**：客户端和存储节点均运行在消费级笔记本电脑（Intel Core i5/i7, 8GB RAM）上，验证了方案对轻量级设备的支持能力。

### 6.2 计算与通信开销分析

实验结果显示，本方案在计算和通信方面具有显著优势：

- **客户端开销**：随着文件数量增加，客户端的加密和标签生成时间呈线性增长，但在可接受范围内（处理数万文件仅需数秒）。
- **存储节点开销**：与基准方案相比，本方案的“单证明”生成时间显著缩短。这是因为基准方案（如Cai et al. + Du et al. ）需要分别执行搜索验证和审计验证两个过程，涉及双倍的配对计算。
- **通信量**：由于证明是聚合的，无论搜索结果包含多少个文件，提交到链上的证明大小基本保持恒定（仅包含几个群元素），极大地节省了带宽。
    
### 6.3 链上Gas开销分析 (核心优势)
在以太坊等区块链上，存储和计算极其昂贵。表6-1展示了本方案与基准方案的Gas开销定性对比（基于实验结论）。
**表 6-1: 链上Gas开销对比分析**

|**操作类型**|**基准方案1 (Arbiter + Merkle)**|**基准方案2 (Arbiter + PolyCommit)**|**本方案 (One Proof)**|**优势分析**|
|---|---|---|---|---|
|**Setup**|低|中|**低**|仅需发布少量公共参数|
|**数据外包**|高 (需存储大量哈希)|高|**低**|仅存储根哈希与聚合索引|
|**搜索与验证**|极高 (双重验证逻辑)|高|**极低**|单次合约调用，聚合验证|
|**总体成本**|昂贵|较贵|**经济适用**|适合公链部署|

实验数据表明，随着数据集（DB3）的增大，基准方案的Gas成本急剧上升（因为需要处理更多的中间哈希值），而本方案的增长曲线非常平缓 1。这证明了“单证明”机制在大规模DSN环境下的经济可行性。
## 7. 结论与展望
### 7.1 研究总结
针对去中心化存储网络中存在的信任缺失与资源受限问题，Song等人提出的基于单证明机制的可验证搜索与完整性审计方案是一次重要的技术突破。该方案通过精巧的密码学设计（关键词关联标签与状态关联指针），成功打破了搜索验证与存储审计之间的壁垒，实现了：

1. **一体化验证**：将两项核心功能的验证开销压缩至单次操作，大幅降低了链上Gas成本。
2. **完全去中心化**：摒弃了对仲裁者或第三方的依赖，完全依靠数学证明和区块链共识保障安全。
3. **强安全性保障**：在提供IND-CKA隐私保护的同时，首次在DSN搜索方案中实现了严格的前向安全性。
### 7.2 局限性与未来方向

尽管表现优异，该方案仍存在一定局限性：

- **查询功能的限制**：当前方案主要支持单关键词精确搜索。对于多关键词（与/或/非逻辑）、模糊搜索或范围查询等复杂操作，方案的聚合结构可能需要大幅调整。
- **侧信道风险**：虽然实现了密文不可区分，但在搜索过程中，访问模式（Access Pattern）的泄露（如某个文件被频繁访问）仍可能被利用进行统计分析攻击。未来的工作可以结合不经意随机访问（ORAM）技术来进一步增强隐私，但这可能会带来额外的性能开销 2。
- **激励机制的缺位**：论文主要解决了技术层面的“可行性”，但在实际的DSN生态中，如何设计激励层（Incentive Layer）以鼓励节点参与复杂的计算验证，仍需结合博弈论进行深入研究。
    

综上所述，该研究为构建安全、高效且经济的下一代去中心化存储网络提供了坚实的理论基础与工程范例。

---