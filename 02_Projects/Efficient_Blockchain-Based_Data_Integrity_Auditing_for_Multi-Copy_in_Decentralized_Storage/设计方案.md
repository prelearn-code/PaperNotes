# 1.背景知识
## PCS-PLONK
>PCS-PLONK 就是：把一个程序的正确执行，转成“几个多项式是否满足某些关系”的问题，再用多
>式承诺来让验证者只花很小代价就能检查这些关系是否真的成立。

缺陷：公共数据很大，可能是几百兆或者几个G。
## PCS-MPAP
>有很多个多项式，  在很多个点上，  
>它们都应该满足某些关系，  
>我不想一个一个证明，  
>能不能一次性打包证明

## 想法
能不能在之前那个可搜索加密与文件完整性的认证与副本同时生成。

将所有涉及到的关键词文件以及所有副本都进行审计，其中保证每个存储节点存储的认证信息不同，文件ID也不同。

在可搜索加密时，对于涉及到的存储节点生成这种客户端可验证的方案，然后客户但可以进行验证。

## 问题 
1. 谁是验证节点？Q: 智能合约
2. 
# 2. 方案设计
## 2.0 在什么样的环境 解决了什么样的问题
**环境**
> 现在借助区块链辅助的文件审计方案环境下，出现了审计请求越来越多，然后区块链开销变大。
> 

**解决了什么问题**
> 本方案是在区块链的存储中，提出一种高效的方案，实现多复制文本的审计。
> 单文件多副本的审计。

## 2.1 Setup Phase

### 2.1.1 KeyGen(λ)

### 2.1.2 RepGen(F)

### 2.1.3 TagGen(sk, $f_{mij} (X)$, $F_{id}$) → $σ_{ij}$.

**计算文件块的认证标签**：
> $$\sigma_{ij} = (H(F_{id}||i||j)*g^{f_{m_{i,j}(\alpha)}})^x$$

其中$f_{m_{i,j}}(\alpha)$是通过文件的第`i`个副本的第`j`个文件块的`s`个块的扇区组成：
> $$f_{m_{i,j}}(X) - \sum_{k=1}^{s}m_{i,j,k}*X^{k-1}$$
> 其中，客户端可以自己计算，服务端也可以通过密文文件进行计算，然后使得这个函数信息保密。目的就是为了不可伪造，不能公用一个认证函数。


### 2.1.4 TagVerfication(pk, $m_{ijk}$, $F_{id}$, $σ_{ij})$ → 0/1
>**验证配对函数**：$$e(\sigma_{ij}, g) = e\left( H(F_{id} \| i \| j) \cdot g^{f_{m_{ij}}(\alpha)}, v \right)$$
>**Prove**:
>	由$\sigma_{ij} = (H(F_{id}||i||j)*g^{f_{m_{i,j}(\alpha)}})^x$带入$e(\sigma_{ij},g)$,得$$e((H(F_{id}||i||j)*g^{f_{m_{i,j}(\alpha)}})^x,g) = e((H(F_{id}||i||j)*g^{f_{m_{i,j}(\alpha)}}),g^x) $$
>	进而由$g^x = v$得到，$$e(\sigma_{ij}, g) = e\left( H(F_{id} \| i \| j) \cdot g^{f_{m_{ij}}(\alpha)}, v \right)$$

## 2.2 Auditing Phase
**阶段概述**：智能合约验证文件的所有副本的完整性。

### 2.2.1 $ChalGen(P ara, nounce) → chal$
>**目的**：生成随机挑战，让生成的数据尽可能的保密。
>**随机数**：合约选择最新的block的nonce数。
>**生成**：Generate a  c-elements set $Q = {(a_j,v_j)}$ and select $r,\gamma \in Z_p$ generate by pseudo-random functions
>	c：The number of challenge blocks.      
>	$a_j$: $a_j \in [1,...,n]$. Present the challange block index.
>	$v_j$: $v_j\in Z_p$ . Present the coefficients of the challenge blocks.
>
>**Out**: $$chal = (Q,r,\gamma)$$


### 2.2.2 $ProofGen(chal, {f_{m_{ij}} (X)}, pk) → Proof_i$
>节点$SSP_i$接收到`chal`之后，计算自己单独的$Proof_i$

>计算公式：$$$$