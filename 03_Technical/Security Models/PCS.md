# 一、PCS-PLONK
---
## 一、PCS-PLONK：基于 KZG 的批量多项式承诺方案 (Batch-KZG)
### 1.1 理论层

**前置数学定义**：

- 假设存在双线性群 $\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T$，阶为大素数 $p$。
- 配对函数 $e: \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$ 具有双线性性质。
- $g_1, g_2$ 分别为 $\mathbb{G}_1, \mathbb{G}_2$ 的生成元。
- 记号：$g_1^x$ 表示标量 $x$ 在群 $\mathbb{G}_1$ 上的编码（同理 $g_2^x$）。
    
---

#### 1. Setup：结构化参考串 (SRS) 的生成

**1. 输入/输出**
- **输入**：安全参数 $\lambda$，最大多项式阶数 $D$。
- **输出**：$srs = (pk, vk)$。其中 $pk$ 用于生成证明，$vk$ 用于验证。

**2. 核心机制（可信设置）**
- 采样随机秘密值 $\tau \in \mathbb{F}_p$（即你提到的 $\alpha$，一旦生成即销毁），这个数据一般就是254位的数据，即$2^{254}$，很难被循环破解。
- 生成 Prover 密钥 ($pk$)：计算 $\tau$ 的幂次在 $\mathbb{G}_1$ 上的映射。
    $$pk = \{ g_1, g_1^\tau, g_1^{\tau^2}, \dots, g_1^{\tau^D} \} \in \mathbb{G}_1^{D+1}$$
- 生成 Verifier 密钥 ($vk$)：主要需要在 $\mathbb{G}_2$ 上对 $\tau$ 进行编码，用于配对验证。
    $$vk = \{ g_2, g_2^\tau \} \in \mathbb{G}_2^2$$
    (注：Verifier 也需要 $g_1$ 及其部分幂次，视具体实现而定，但在批量验证核心步骤中主要用到 $g_2^\tau$)。

**3. 理论作用**
- 构建了**陷门（Trapdoor）**。任何多项式 $f(X) = \sum a_i X^i$ 都可以通过线性组合 $pk$ 中的元素，在不暴露 $a_i$ 的情况下计算出 $g_1^{f(\tau)}$。
    

---

#### 2. Commit：多项式向量的承诺

**1. 输入/输出**

- **输入**：多项式列表 $\vec{f} = (f_1(X), f_2(X), \dots, f_k(X))$，其中 $f_i(X) \in \mathbb{F}_p[X]$。
- **输出**：承诺列表 $\vec{C} = (C_1, C_2, \dots, C_k) \in \mathbb{G}_1^k$。
    

**2. 核心机制（MSM 计算）**

- 对于每一个多项式 $f_j(X) = \sum_{i=0}^{d} c_{j,i} X^i$，Prover 计算：
    $$C_j = \prod_{i=0}^{d} (g_1^{\tau^i})^{c_{j,i}} = g_1^{\sum_{i=0}^{d} c_{j,i} \tau^i} = g_1^{f_j(\tau)}$$
- 这实际上是一个**多标量乘法 (MSM)** 操作。
    

**3. 理论作用**
- **同态绑定**：利用离散对数困难假设（DL），Prover 无法找到另一个 $f'_j \neq f_j$ 使得 $g_1^{f'_j(\tau)} = C_j$。这实现了对多项式的“指纹锁定”。
    

---

#### 3. CreateWitness：评估与聚合证明

**1. 场景**
- Verifier 询问所有多项式在点 $z$ 处的值。
- Prover 返回值列表 $(y_1, \dots, y_k)$，其中 $y_j = f_j(z)$。
    

**2. 核心机制（随机线性组合 RLC）**

- **引入随机挑战**：Verifier 发送随机数 $v \in \mathbb{F}_p$。
- 构造聚合多项式 (明文域计算)：
    Prover 在本地计算一个组合多项式 $h(X)$，其目的是将 $k$ 个验证方程 $f_j(z)=y_j$ 压缩为一个：
    $$h(X) = \sum_{j=1}^{k} v^{j-1} \cdot (f_j(X) - y_j)$$
    注：此时 $h(z) = \sum v^{j-1}(f_j(z) - y_j) = 0$。
- 构造商多项式 (多项式除法)：
    由于 $h(z)=0$，根据多项式剩余定理，$h(X)$ 必能被 $(X-z)$ 整除。Prover 计算商多项式 $q(X)$：
    $$q(X) = \frac{h(X)}{X - z}$$
- 生成唯一 Witness (密文域计算)：
    Prover 使用 $pk$ 对商多项式 $q(X)$ 进行承诺，生成证明 $\pi$（即你文中的 $W$）：
    $$W = g_1^{q(\tau)}$$
**3. 理论作用**
- **Schwartz-Zippel 引理的应用**：如果 Prover 在任意一个 $f_j(z) = y_j$ 上撒谎，那么 $(f_j(X) - y_j)$ 就不能被 $(X-z)$ 整除。在随机权重 $v$ 的作用下，聚合后的 $h(X)$ 能够被 $(X-z)$ 整除的概率是可以忽略不计的（只有 $1/p$ 的几率蒙混过关）。

---

#### 4. VerifyEval：双线性配对校验
 1. 输入
- 承诺列表 $\{C_j\}$，值列表 $\{y_j\}$，证明 $W$，挑战点 $z$，随机权重 $v$。
- SRS：$g_1, g_2, g_2^\tau$。
2. 核心机制（Verifier 的模拟与配对）
Verifier 的目标是验证等式：$h(\tau) \stackrel{?}{=} q(\tau) \cdot (\tau - z)$。由于他不知道 $\tau$，必须在指数上利用配对进行验证。

- 步骤 A：模拟聚合承诺 $C_{agg}$
    Verifier 利用同态性质，在 $\mathbb{G}_1$ 上计算 $h(\tau)$ 的承诺部分：
    $$C_{agg} = \sum_{j=1}^k v^{j-1} \cdot C_j = g_1^{\sum v^{j-1} f_j(\tau)}$$
- 步骤 B：计算聚合值 $y_{agg}$
    Verifier 在标量域 $\mathbb{F}_p$ 上计算值的加权和：
    $$y_{agg} = \sum_{j=1}^k v^{j-1} \cdot y_j$$
- 步骤 C：构造配对等式
    验证的核心逻辑是检查：$C_{agg} - g_1^{y_{agg}} \stackrel{?}{=} W \cdot (\tau - z)$。
    转化为配对公式（Pairing Equation）：
    $$e(C_{agg} \cdot g_1^{-y_{agg}}, g_2) \stackrel{?}{=} e(W, g_2^\tau \cdot g_2^{-z})$$
    _解释：_
    - 左边 $= e(g_1^{h(\tau)}, g_2) = e(g_1, g_2)^{h(\tau)}$
    - 右边 $= e(g_1^{q(\tau)}, g_2^{\tau-z}) = e(g_1, g_2)^{q(\tau)(\tau-z)}$
    - 若左右相等，则意味着 $h(\tau) = q(\tau)(\tau-z)$ 成立。
        

## 1.2 例子
### 1. Setup 阶段（可信设置）
这一步由“仪式”完成，完成后 $\alpha$ 立即销毁。
- **秘密参数（Toxic Waste）**：$\alpha = 5$（只有上帝知道，Prover/Verifier 都不知道）。
- 生成公开参数（SRS / pk）：
    计算 $\alpha$ 的幂次映射到群上：
    - $SRS_0 = g^{\alpha^0} = g^1$
    - $SRS_1 = g^{\alpha^1} = g^5$
    - $SRS_2 = g^{\alpha^2} = g^{25}$
- **公开输出**：$pk = \{g^1, g^5, g^{25}\}$。
    - _注意：此时全世界只看得到这三个点，谁也不知道它们背后的指数是 1, 5, 25。_
---
### 2. Commit 阶段（Prover 的“盲算”）
**任务**：Prover 想对两个多项式进行承诺。
- $f_1(X) = X + 2$
- $f_2(X) = 3X$

Prover 的操作（在密文世界拼积木）：
Prover 不知道 $\alpha=5$，但他知道 $f_1$ 的系数是 [2, 1]（即 $2 + 1\cdot X$）。他利用 SRS 线性组合：
- 计算 $C_1$：
    $$C_1 = (SRS_0)^2 \cdot (SRS_1)^1 = (g^1)^2 \cdot (g^5)^1 = g^{2+5} = g^7$$
- 计算 $C_2$：
    $f_2$ 系数是 [0, 3]。
    $$C_2 = (SRS_0)^0 \cdot (SRS_1)^3 = g^0 \cdot (g^5)^3 = g^{15}$$
> **严谨点**：Prover 计算出 $C_1=g^7$ 和 $C_2=g^{15}$，但他完全不知道指数是 7 和 15。他只是把公开的 $SRS$ 点按照多项式系数进行了“加权混合”。
---
### 3. CreateWitness 阶段（聚合与商）
**挑战**：Verifier 发起询问。
- **评估点**：$z = 2$。
- **随机权重**：$v = 4$（用于聚合）。

**Prover 的本地计算（明文世界）**：
1. **计算值**：
    - $y_1 = f_1(2) = 2 + 2 = 4$
    - $y_2 = f_2(2) = 3(2) = 6$
    - _Prover 发送 $y_1, y_2$ 给 Verifier。_
2. 构造聚合多项式 $h(X)$：
    目标是证明 $f_1$ 和 $f_2$ 减去对应值后，能被 $(X-z)$ 整除。
    $$h(X) = (f_1(X) - y_1) + v \cdot (f_2(X) - y_2)$$
    代入数值：
    $$h(X) = (X + 2 - 4) + 4 \cdot (3X - 6)$$
    $$h(X) = (X - 2) + 12X - 24 = 13X - 26$$
    $$h(X) = 13(X - 2)$$
3. 计算商多项式 $q(X)$：
    $$q(X) = \frac{h(X)}{X - z} = \frac{13(X-2)}{X-2} = 13$$
    注意：在这个简单的例子里商是常数 13。如果是更复杂的多项式，商会是一个关于 X 的多项式。
    
Prover 生成 Witness（回到密文世界）：
Prover 需要计算 $W = g^{q(\alpha)}$。
因为 $q(X) = 13$（常数项为 13，一次项为 0），Prover 再次使用 SRS：
$$W = (SRS_0)^{13} = (g^1)^{13} = g^{13}$$

Prover 发送 $W$ 给 Verifier。

---

### 4. VerifyEval 阶段（双线性配对检查）

Verifier 收到：
- 承诺：$C_1=g^7, C_2=g^{15}$
- 值：$y_1=4, y_2=6$
- 证据：$W=g^{13}$
- 参数：$z=2, v=4$
- SRS中的特殊点：$g^\alpha$（即 $SRS_1$）

**Verifier 的工作**：

1. 模拟聚合承诺 $C_{agg}$（在群上计算）：
2. $$C_{agg} = C_1 \cdot (C_2)^v = g^7 \cdot (g^{15})^4 = g^{7 + 60} = g^{67}$$
3. 计算聚合值 $y_{agg}$（在标量上计算）：
    $$y_{agg} = y_1 + v \cdot y_2 = 4 + 4(6) = 28$$
    
    将此值转为群元素：$Y = g^{28}$。
    
4. 计算“承诺差” $D$：
    $$D = C_{agg} \cdot Y^{-1} = g^{67} \cdot g^{-28} = g^{39}$$
    这一步代表了多项式 $h(\alpha)$ 的承诺。
    
5. 最终配对（Pairing）验证：
    
    验证核心等式：$e(D, g) \stackrel{?}{=} e(W, g^\alpha \cdot g^{-z})$
    - **左边（LHS）**：$e(g^{39}, g^1) \rightarrow$ 目标配对值 $Target^{39}$。
    - 右边（RHS）：
        Verifier 并没有 $\alpha$，但他有 $g^\alpha$ ($SRS_1$)。他计算 $SRS_1 \cdot g^{-z} = g^\alpha \cdot g^{-2} = g^{\alpha-2}$。
        $$e(W, g^{\alpha-2}) = e(g^{13}, g^{\alpha-2})$$
        根据配对性质，指数相乘：$13 \cdot (\alpha - 2)$。
        因为上帝视角下 $\alpha=5$，所以 $13 \cdot (5-2) = 13 \cdot 3 = 39$。
        $\rightarrow$ 结果也是 $Target^{39}$。
    
    **结论**：$39 = 39$，验证通过！

## 1.3、进阶实例：非常数商多项式演示

**1. Setup 阶段**

- **秘密设定**：$\alpha = 10$（上帝视角）。
- **公开公钥**：$pk = (g, g^{10}, g^{100}, \dots)$。
- **直觉**：$\alpha=10$ 是标尺。因为我们要处理二次多项式，所以 SRS 里必须包含 $g^{100}$ (即 $g^{\alpha^2}$)。

**2. Commit 阶段**

- 假设数据：Prover 有一个二次多项式：
    $$f(X) = X^2 - 5$$
- **计算承诺**：利用 $pk$ 计算 $f(\alpha)$ 的群形式。
    
    - 指数计算（上帝视角）：$f(10) = 10^2 - 5 = 95$。
    - 实际操作（Prover 视角）：$C = (SRS_2)^1 \cdot (SRS_0)^{-5} = g^{100} \cdot g^{-5} = g^{95}$。
    - **输出**：$C = g^{95}$。
        
- **直觉**：多项式 $X^2-5$ 被锁定在了 $g^{95}$ 这个点上。
    

**3. CreateWitness 阶段**

- **挑战情景**：Verifier 想验证在点 $r=3$ 处，函数值是否为 $4$。
    
    - 验证：$3^2 - 5 = 4$，数值是对的。
        
- **计算商多项式 $q(X)$**：
    
    - 分子：$f(X) - f(r) = (X^2 - 5) - 4 = X^2 - 9$。
        
    - 分母：$X - r = X - 3$。
        
    - 除法运算：
        
        $$q(X) = \frac{X^2 - 9}{X - 3} = \frac{(X-3)(X+3)}{X - 3} = X + 3$$
        
    - **关键点**：这里的商多项式 $q(X) = X + 3$ 是一个含有 $X$ 的式子，不再是常数。
        
- **生成 Witness**：
    
    - Prover 需要计算 $q(\alpha)$ 的群元素。
        
    - 指数计算：$q(10) = 10 + 3 = 13$。
        
    - 实际操作：$W = SRS_1 \cdot (SRS_0)^3 = g^{10} \cdot g^3 = g^{13}$。
        
- **直觉**：Prover 发送 $W=g^{13}$，代表证明多项式 $X+3$ 在秘密点 $\alpha$ 处的值。
    

**4. VerifyEval 阶段**

- **验证逻辑**：Verifier 检查配对等式 $e(C \cdot g^{-y}, g) \stackrel{?}{=} e(W, g^\alpha \cdot g^{-r})$。
    
- **代数检查**（指数层面）：
    
    - 左边（承诺 - 值）：
        
        $$C - f(r) = 95 - 4 = 91$$
        
    - 右边（Witness $\times$ 挑战差）：
        
        此处 Verifier 计算 $(\alpha - r) = 10 - 3 = 7$。
        
        $$W \cdot (\alpha - r) \Rightarrow 13 \times 7 = 91$$
        
- **直觉**：$91 = 91$，验证通过。
    
- **结论**：Verifier 确信 $X^2-5$ 在 $X=3$ 处的值确实是 4，且 $W$ 是由合法的商多项式生成的。
    

---

### 对照总结：常数商 vs 多项式商

|**特性**|**上一个例子 (f(X)=3+2X)**|**这个例子 (f(X)=X2−5)**|
|---|---|---|
|**商多项式 $q(X)$**|**常数** (2)|**一次多项式** ($X+3$)|
|**Witness 计算**|$W = g^2$ (无需 SRS 高阶项)|$W = g^\alpha \cdot g^3$ (用到 SRS 的 $g^\alpha$)|
|**验证本质**|验证 $4 = 2 \times 2$|验证 $91 = 13 \times 7$|
|**复杂度**|简单除法|多项式长除法|

 
### 附：四阶段统一对照表
| **阶段**            | **理论本质**         | **例子中的直觉**                          |
| ----------------- | ---------------- | ----------------------------------- |
| **Setup**         | 生成通用 SRS         | 准备一把公用尺子                            |
| **Commit**        | 独立承诺             | 多项式 $\rightarrow$ 一堆箱子 $(C_1, C_2)$ |
| **CreateWitness** | **随机线性组合 (RLC)** | 加权打包：$Box_1 + 2 \cdot Box_2$        |
| **VerifyEval**    | 批量验证聚合结果         | 拆开打包后的这一个箱子，全对                      |
# 二、PCS-MPAP
---
## 2.1、理论层：单点 PCS 核心机制

**1. Setup：构建基于 $\alpha$ 的陷门环境**
- **输入/输出**：输入安全参数 $\lambda$ $\rightarrow$ 输出 $(pk, sk)$。
- **核心机制**：生成群 $G$ 的生成元 $g$ 和一个随机秘密值 $\alpha$（即 $sk$）。
- **公钥结构**：$pk = (g, g^\alpha, g^{\alpha^2}, \dots, g^{\alpha^{s-1}})$。这是经典的“Powers of Tau”结构。
- **理论作用**：将秘密 $\alpha$ 的不同幂次“加密”后公开，允许 Prover 在不知道 $\alpha$ 的情况下计算 $f(\alpha)$ 的加密值。

**2. Commit：多项式的代数绑定**
- **输入/输出**：输入 $pk, f(X)$ $\rightarrow$ 输出承诺 $C$。
- **核心机制**：Prover 利用 $pk$ 计算 $C = g^{f(\alpha)}$。
- **理论作用**：利用同态性质，将多项式 $f(X)$ 在秘密点 $\alpha$ 处求值并映射到群上。由于离散对数难题，Prover 无法找到另一个多项式 $f'(X)$ 产生相同的 $C$，从而实现“绑定”。
**3. CreateWitness：商多项式的存在性证明**
- **输入/输出**：输入 $pk, f(X), r$ $\rightarrow$ 输出证据 $W$。
- **核心机制**：
  - 计算商多项式：$\psi(X) = \frac{f(X) - f(r)}{X - r}$。根据多项式余数定理，只有当 $f(r)$ 是真实评估值时，$\psi(X)$ 才是一个整多项式（无余数）。
  - 计算 Witness：$W = g^{\psi(\alpha)}$。
- **理论作用**：$W$ 是“商多项式存在”的加密证明。它证明了 $(f(X) - f(r))$ 能被 $(X - r)$ 整除。

**4. VerifyEval：双线性配对校验**
- **输入/输出**：输入 $pk, r, C, W$（以及声称的值 $y=f(r)$） $\rightarrow$ 输出 0/1。
- **核心机制**：验证者通过双线性配对（Pairing）检查等式：$e(C \cdot g^{-f(r)}, g) \stackrel{?}{=} e(W, g^\alpha \cdot g^{-r})$。
- **理论作用**：这是在群上验证代数关系 $(f(\alpha) - f(r)) = \psi(\alpha) \cdot (\alpha - r)$ 是否成立。如果成立，说明 Prover 没有撒谎。

## 2.2、实例层：极简直觉演示（单点版）

**1. Setup 阶段**
- **秘密设定**：系统选定秘密 $\alpha = 7$（除了上帝无人知晓）。
- **公开公钥**：发布 $pk = (g, g^7, g^{49}, \dots)$。
- **直觉**：$\alpha=7$ 是用来冻结多项式的“核心钉子”。

**2. Commit 阶段**
- **假设数据**：Prover 有一个多项式 $f(X) = 3 + 2X$。
- **计算承诺**：利用 $pk$ 计算 $f(\alpha)$ 的群形式。
  - 指数计算：$f(7) = 3 + 2(7) = 17$。
  - 输出：$C = g^{17}$。
- **直觉**：多项式被压缩成了 $g^{17}$，承诺已锁定。

**3. CreateWitness 阶段**
- **挑战情景**：Verifier 想验证 $r=5$ 时，函数值是否为 $13$。
- **计算商多项式**：
  - $\psi(X) = \frac{f(X) - f(r)}{X - r} = \frac{(3+2X) - 13}{X - 5} = \frac{2X - 10}{X - 5} = 2$。
  - 此处商多项式 $\psi(X)$ 恰好是常数 2。
- **生成 Witness**：
  - $W = g^{\psi(\alpha)} = g^{\psi(7)} = g^2$。
- **直觉**：Prover 发送 $W=g^2$，意思是“我把整除后的结果给你算好了”。

**4. VerifyEval 阶段**
- **验证逻辑**：Verifier 检查“除法关系”在加密状态下是否成立。
- **代数检查**（指数层面）：
  - 左边：$C - f(r) = 17 - 13 = 4$。
  - 右边：$W \cdot (\alpha - r) = 2 \cdot (7 - 5) = 2 \cdot 2 = 4$。
- **直觉**：左右两边相等，验证通过。Verifier 确信 $f(5)=13$ 是真的，且来自于承诺 $C$。

### 附：四阶段统一对照表
| **阶段** | **理论本质** | **例子中的直觉** |
|---|---|---|
| **Setup** | 生成秘密参数 $\alpha$ | 埋下一个秘密数字 7 |
| **Commit** | $C = g^{f(\alpha)}$ | 多项式 $\rightarrow$ 一个数 $g^{17}$ |
| **CreateWitness** | 构造商多项式 $\psi(X)$ | 算出除法结果 $W=g^2$ |
| **VerifyEval** | 验证双线性配对 | 确认 $4 = 2 \times 2$，整除成立 |


