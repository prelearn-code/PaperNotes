

# 1. rsa
## 题目
```
e = 65537
n = 86934482296048119190666062003494800588905656017203025617216654058378322103517
```

## WP
### 理论
![[../../../assets/pics/Pasted image 20251216112510.png]]
直接分解得到p，q
然后生成私钥，进行解密
```
openssl pkeyutl -decrypt -inkey rsa_key.pem -in flag.enc -out text.text
```

### code(生成私钥)
```python
import os

from cryptography.hazmat.primitives.asymmetric import rsa

from cryptography.hazmat.primitives import serialization

  

# ================= 配置区域 =================

  

# 1. 输入你的公钥 N 和 e

# (SageMath 会自动处理大整数，直接填入即可)

n = 86934482296048119190666062003494800588905656017203025617216654058378322103517

e = 65537

  

# 2. 指定输出路径

output_file_path = "/home/zsw/codes/CTF/data/rsa/rsa_private.pem"

  

# ===========================================

  

print(f"[-] 正在分解 n ({n.bit_length()} bits)...")

  

# 【核心步骤】使用 SageMath 内置函数分解 n

# factor(n) 返回的是一个分解对象，类似于 list([(p, 1), (q, 1)])

factors_obj = factor(n)

  

# 检查分解结果是否符合 RSA 标准 (两个质数)

if len(factors_obj) != 2:

    print(f"[!] 警告: n 分解后的因子数量不是 2，结果为: {factors_obj}")

    print("    尝试取前两个因子作为 p 和 q...")

  

p = factors_obj[0][0]

q = factors_obj[1][0]

  

print(f"    p = {p}")

print(f"    q = {q}")

  

print("[-] 正在计算私钥 d 和 CRT 参数...")

  

# 计算欧拉函数 phi

phi = (p - 1) * (q - 1)

  

# 计算私钥 d = e^-1 mod phi

d = inverse_mod(e, phi)

  

# 计算 CRT 参数

# 注意：必须转换为 Python 原生 int，否则 cryptography 库可能会报错

dp = int(d % (p - 1))

dq = int(d % (q - 1))

qi = int(inverse_mod(q, p))

  

# 将 Sage 的 Integer 转换为 Python int

n_int = int(n)

e_int = int(e)

d_int = int(d)

p_int = int(p)

q_int = int(q)

  

print("[-] 正在生成 PEM 文件...")

  

try:

    # 构造 RSA 私钥对象

    private_numbers = rsa.RSAPrivateNumbers(

        p=p_int,

        q=q_int,

        d=d_int,

        dmp1=dp,

        dmq1=dq,

        iqmp=qi,

        public_numbers=rsa.RSAPublicNumbers(e=e_int, n=n_int)

    )

  

    private_key = private_numbers.private_key()

  

    # 导出为 PEM 格式

    pem_bytes = private_key.private_bytes(

        encoding=serialization.Encoding.PEM,

        format=serialization.PrivateFormat.TraditionalOpenSSL,

        encryption_algorithm=serialization.NoEncryption()

    )

  

    # 确保目录存在

    output_dir = os.path.dirname(output_file_path)

    if output_dir and not os.path.exists(output_dir):

        os.makedirs(output_dir)

  

    # 写入文件

    with open(output_file_path, "wb") as f:

        f.write(pem_bytes)

    print(f"[SUCCESS] 私钥已成功写入: {output_file_path}")

  

except Exception as err:

    print(f"[ERROR] 生成失败: {err}")
```


# 2. RSA2
## 题目
```python
N = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471

e = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085

  
import hashlib

flag = "flag{" + hashlib.md5(hex(d)).hexdigest() + "}"
```

## WP
### 理论分析（Wiener's Attack）
#### 条件
* **已知条件**：公钥 $(N, e)$。 * **特征表现**： * $e$ 非常大，数量级接近 $N$。 * $d$ 非常小，满足 $d < \frac{1}{3} N^{\frac{1}{4}}$。

#### 数学原理
> RSA 的核心等式为 $ed \equiv 1 \pmod{\phi(N)}$，即存在整数 $k$ 使得： $$ed - k\phi(N) = 1$$
两边同除以 $d\phi(N)$，并利用 $\phi(N) \approx N$ 的性质，可以推导出： $$\left| \frac{e}{N} - \frac{k}{d} \right| < \frac{1}{2d^2}$$
根据勒让德定理，如果上述不等式成立，那么分数 $\frac{k}{d}$ 必然是 $\frac{e}{N}$ 的**连分数展开（Continued Fraction）**中的某一个**渐进分数（Convergent）。
由 $d$ 得到 $\phi(N)$ ,然后对于N进行分解。$$N-\phi(N)+1 =p+q $$ $$p*q = N$$

#### 代码
**求解d**
```python
  
# Copy this to a .sage file or SageMath cell
def wiener_attack(e, n):

    print(f"[*] Testing Wiener's Attack...")

    # 1. 将 e/n 展开为连分数

    # SageMath 的 continued_fraction 处理大数非常快

    cf = continued_fraction(Integer(e)/Integer(n))

    # 2. 循环遍历每一个渐进分数 k/d

    for frac in cf.convergents():

        k = frac.numerator()

        d = frac.denominator()

        if k == 0: continue

        # 3. 验证 d 是否正确

        # phi = (ed - 1) / k

        if (e * d - 1) % k != 0:

            continue

        phi = (e * d - 1) // k

        # 4. 构建一元二次方程 x^2 - ((n - phi) + 1)x + n = 0

        # 如果方程有整数根 (p, q)，说明 d 是正确的

        # 判别式 delta = b^2 - 4ac

        b = -(n - phi + 1)

        delta = b^2 - 4 * n

        if delta >= 0 and is_square(delta):

            # 找到解了！

            print(f"[+] Success! Found d: {d}")

            # 如果需要求 p 和 q

            # p = (-b + sqrt(delta)) / 2

            # q = (-b - sqrt(delta)) / 2

            # print(f"p: {(-b + sqrt(delta)) // 2}")

            # print(f"q: {(-b - sqrt(delta)) // 2}")

            return d

    print("[-] Wiener's Attack failed. d might be larger.")

    return None

  

# ==========================================

# 在这里填入你的题目数据

n = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471

e = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085

  

d = wiener_attack(e, n)

print(d)
```

**获得flag**(python2运行)
```python
import hashlib
d = 8920758995414587152829426558580025657357328745839747693739591820283538307445
flag = "flag{" + hashlib.md5(hex(d)).hexdigest() + "}"
print(flag)
```

**Flag**
```plaintext
flag{47bf28da384590448e0b0d23909a25a4}
```


# 3. RSA & what
## 题目
### python代码
```python
from Crypto.Util.number import bytes_to_long, getPrime

from random import randint

from gmpy2 import powmod

p = getPrime(2048)

q = getPrime(2048)
N = p*q

Phi = (p-1)*(q-1)
def get_enc_key(N,Phi):

    e = getPrime(N)

    if Phi % e == 0:

        return get_enc_key(N, Phi)

    else:

        return e

e1 = get_enc_key(randint(10, 12), Phi)

e2 = get_enc_key(randint(10, 12), Phi)

  

fr = open(r"./base64", "rb")#flag is in this file

f1 = open(r"./HUB1", "wb")

f2 = open(r"./HUB2", "wb")

base64 = fr.read(255)

f1.write("%d\n%d\n" % (N, e1))

f2.write("%d\n%d\n" % (N, e2))

while len(base64)>0:

    pt = bytes_to_long(base64)

    ct1 = powmod(pt, e1, N)

    ct2 = powmod(pt, e2, N)

    f1.write("\n%d" % ct1)

    f2.write("\n%d" % ct2)

    base64 = fr.read(255)

fr.close()

f1.close()

f2.close()
```
### HUB1
```txt
785095419718268286866508214304816985447077293766819398728046411166917810820484759314291028976498223661229395009474063173705162627037610993539617751905443039278227583504604808251931083818909467613277587874545761074364427549966555519371913859875313577282243053150056274667798049694695703660313532933165449312949725581708965417273055582216295994587600975970124811496270080896977076946000102701030260990598181466447208054713391526313700681341093922240317428173599031624125155188216489476825606191521182034969120343287691181300399683515414809262700457525876691808180257730351707673660380698973884642306898810000633684878715402823143549139850732982897459698089649561190746850698130299458080255582312696873149210028240898137822888492559957665067936573356367589784593119016624072433872744537432005911668494455733330689385141214653091888017782049043434862620306783436169856564175929871100669913438980899219579329897753233450934770193915434791427728636586218049874617231705308003720066269312729135764175698611068808404054125581540114956463603240222497919384691718744014002554201602395969312999994159599536026359879060218056496345745457493919771337601177449899066579857630036350871090452649830775029695488575574985078428560054253180863725364147
1697

412629526163150748619328091306742267675740578011800062477174189782151273970783531227579758540364970485350157944321579108232221072397135934034064481497887079641131808838242743811511451355024436983050572020925065644355566434625618133203024215941534926113892937988520918939061441606915556516246057349589921494351383160036280826024605351878408056180907759973804117263002554923041750587548819746346813966673034182913325507826219961923932100526305289894965216608254252188398580139545189681875824089456195044984585824938384521905334289906422454152976834867304693292466676355760173232407753256256317546190171995276258924613533179898467683358934751999655196790168438343198229183747091108262988777659858609744709324571850262293294975336628234767258858873839342596887193772615000676401522431518310648303975593582965021189182246986957349253156736526071639973844039068996404290548474640668851856078201093335425412842295604919065487301340901573809617549185106072798799159726375235125260509158832996701927878713084753334549129580912412168594170659605421750204835970231909591063407612779337478065175988365401590396247576709343727196106058477166945670117868989025903023998142850338956985816131805349549059377047477131270847579095628384569645636821650
494644347943710545224678831941589086572700792465459558770782213550069709458568349686998660541810166872034041584767487150140111151788221460027897193248273461607411027815984883969396220626358625041781558277804930212654296704055890683796941327712758797770820006623289146990000114915293539639766846910274034245607746230740851938158390562286057002223177609606376329007676845450142537930798148258428701466415483232670659815791064681384406494388237742330786225557303988025468036820082959712050733095860546860468575857084616069132051094882919253745234762029759124776348047587755897123575123506976140900565238840752841856713613368250071926171873213897914794115466890719123299469964019450899291410760762179836946570945555295288184698184555018368687708432612286248476073758067175481771199066581572870175460016017100414479346437034291784837132240891321931601494414908927713208448927221095745802380014441841139882391378410438764884597938773868771896252329517440068673532468372840830510218585255432000690265226016573313570977945083879214961394087065558376158826938257664840570952233832852869328785568175434516247720356520242602299510374317488182738732700078879665745909603766482100138001417023680647717824323143388857817595766172152883484274718248
152942283599728307168144137370127212672611894072038732126041098102628831053000986759260271210671922070555948023688596575415822984026159010574404359474670428678518262175033880513984372909748992727828381694416776740981021730545374002974037896534944567124543272737618380646771071804878796585983783360553761828325817820260204820004421979881871027255562690952334900616675606524933557440263648233514757200263521499508373975003431306847453046714027687108396945719803444444954079308404947126216395526551292104722047878178373207886033071857277857997932255251315982837892164421298202073945919187779856785892717251746704537315003771369737854896595170485152591013676942418134278534037654467840633528916812275267230155352077736583130992587670941654695382287023971261529987384520843829695778029311786431227409189019205818351911572757145556993606643464336196802350204616056286497246016800105003143046120608673496196758720552776772796609670537056331996894322779267635281472481559819839042424017171718303214059720568484939239370144038161541354254182769979771948759413102933987773401644506930205164891773826513161783736386604783484446345744957119469799231796368324927570694496679453313927562345656690240414624431304646248599226046524702364131095964335
79717988936247951265489157583697956031893477858854186991051529161879478488281744062318600470906120960002282886511477294555606503083169449335174864424180701080203993329996226566203834693869525797695969610065991941396723959032680019082506816443041598300477625793433080664346470586416385854692124426348587211026568667694805849554780794033764714016521711467557284846737236374990121316809833819996821592832639024026411520407330206281265390130763948165694574512140518775603040182029818771866749548761938870605590174330887949847420877829240131490902432602005681085180807294176837646062568094875766945890382971790015490163385088144673549085079635083262975154206269679142412897438231719704933258660779310737302680265445437771977749959110744959368586293082016067927548564967400845992380076107522755566531760628823374519718763740378295585535591752887339222947397184116326706799921515431185636740825707782742373783475781052674257292910213843986132987466810027275052416774693363446184518901899202502828670309452622347532932678874990809930682575738653876289384151496807194146308614368821006660626870989784697045160231069428458961107751207771093777394616856305293335603892178327520756554333365975114235981173451368131680404850832773147333013716920
123111353650401158556639983459870663057297871992927053886971224773529636525110628183715748795987525113177540092814119928708272290370336537110381023134637759740716140969662183269370676630325583385284994943164692397459103195434968057377474610500216801375394703781249039351368816958227409657934091741509357152328382960684515093945552479461382281913961956745154260686029997827565075768703774895750561575155143606297116391666385705899138085693913246313778033627210312268959737394553510894720099165193981333775907531107232556909478156441457899797515694348816961762796703443502856101079430585547997496001098926600499728389113862894833789669213630332988693669889340482430613291490613803204484751470676686041002772556117213612152322606737150858116122936539131795111263513114569794532805886643087299918196635113037777138666914296986040549274559835214505300618256105508764026461518876579387159881983544667258537064954616097750399839661065797883103731694314852301848272092388637114950059216922969842082648527035538090054093890365647676119748995243416337805666557501345234056968476142608491830438065401219751688687373709390057521910942736632126729711606256158399963682990881473178216060827021373776598901281958527655543318413664277921492723185984
36869806815936046911848195817405817350259890871483063184373728397968909458432625046025376290214729914038387534731762237978339011724858818860181178811639468996206294711495853807311240013786226884265118119546377272154555615363105236192878292703331473547623021744317034819416624562896226194523639793573028006666236271812390759036235867495803255905843636447252225413871038762657801345647584493917576263471587347202664391908570140389126903204602391093990827188675090199750617303773574821926387194478875191828814971296674530519321530805302667925998711835019806761133078403281404889374663875077339168901297819436499920958268483684335998301056068380228873524800383911402490807139268964095165069610454677558808756444381542173782815227920906224931028457073652453777424387873533280455944646592996920617956675786286711447540353883400282402551158169958389450168079568459656526911857835375748015814860506707921852997096156275804955989964215077733621769938075413007804223217091604613132253046399456747595300404564172224333936405545921819654435437072133387523533568472443532200069133022979195685683508297337961701169394794966256415112246587706103819620428258245999539040721929317130088874161577093962579487428358736401687123174207198251449851429295
```
### HUB2
```txt
785095419718268286866508214304816985447077293766819398728046411166917810820484759314291028976498223661229395009474063173705162627037610993539617751905443039278227583504604808251931083818909467613277587874545761074364427549966555519371913859875313577282243053150056274667798049694695703660313532933165449312949725581708965417273055582216295994587600975970124811496270080896977076946000102701030260990598181466447208054713391526313700681341093922240317428173599031624125155188216489476825606191521182034969120343287691181300399683515414809262700457525876691808180257730351707673660380698973884642306898810000633684878715402823143549139850732982897459698089649561190746850698130299458080255582312696873149210028240898137822888492559957665067936573356367589784593119016624072433872744537432005911668494455733330689385141214653091888017782049043434862620306783436169856564175929871100669913438980899219579329897753233450934770193915434791427728636586218049874617231705308003720066269312729135764175698611068808404054125581540114956463603240222497919384691718744014002554201602395969312999994159599536026359879060218056496345745457493919771337601177449899066579857630036350871090452649830775029695488575574985078428560054253180863725364147
599

592169079372093727306100216011395857825646323934289480976073629037543922902098120901138454462177159996376654176248238979132528728327590301098966139983157980612320563496546128644967731000716697705104079039156276714872147463350811303393260622707024952543509891692246246277965823414460326811240048060543656588688604452353899779068825120910282167004715339763187734797180326976132213325054697165320479166356562518029805927741656605174809726397565772271562066078076105491745903986597877400370206718954975288721072048333678609055008135809089304229015364348490924974097403734627265297637171818849461766523691595241613878709865506436588268999163342945070495338153600520537498539457396582804692959296612715752573140296135784933206146091436617979599749774330699946637591406356289409716084034451049094715202196203486088368791744107629271647320273259836915312794297246589501008666299165717722507702866033454215783240025504356157664454861755286285777763585177751796252655008206383024707883077513745863312079349790275094080707502392866946325796914450602264462588722052297430827681750827349094323968337670311272933785838850649376115667223821665435911506351891489985627506615492005617098615432522564204152887767244129985681083657783356557756654335186
373940646416832740878733255707567753033716583448402000789202767511920210382830343955553654111486728333980557319799362514960627879016797491389812007768832730979916230647641872759001906846747977631675704310179448857128160385701185892914523053669366534408863734305635222625590986006420486092550427301086984563126480814987024980594613542978310129247678826691418335300577577527951623696426435497835228167084738007750914270251001921329521479047662848650808989996085600197309361410863238526802127877523767262921515150984998560136647154865791163316503073285223966216441025637452229043510097323724381056976302288136843260163922706692913035222445496716008888946581535004546355744211680390731257309941902587303353139951102244865270295414474488798335404630458489706639805186573874814586736746232358849677477533671968344154242963289415569487579895910660999043578737461300406937828924818002658292769882181668784501439254131996848948120781562158861495883827848139425862249576454689133681009549361314460818658995959098228995702202268649635363105549975932395335076521137604288520082040121286614922986554652700056148966514178935952363036963217619879899671383604638416567950421350546204434902113156720006282720889591288850271076074941927715678306057176
527630926460622936571385649841758214453416849039412401087443444317101857090904711485538107058823056085840539073345920792871368232355475394571098380596835468509997340505604333730547799560998822989747473780307779717715522787724471724766494090783971030594671013168209717686720448579582618378459567979027822271918653169622428153856198907810040224340270362413432495029672123261375400927159831537760709974778708160583252613784358234858583174544777979242887938827573604837766801998381379999076416444683891078093889686055482709838668356120916040352123019019255084513769603803814947774554028717814638951416291274696771515474086351482107953150253616922787262398450376249126999644026382478413080973933173079111305142716133389111399235545279259017424722601848670061556859163943895466553927946412523750166582734005733378328468250568944945912238495877929717101722314678120172228493787964904072583905721074766711732215815561012960394537195757832959268603775112932862105945720853959285187521763557915356428113876893276879775603217718981852114599706699524551973934242045743122744146361596971245034059345915315495232135483464496114770357536576200511490922413208178149869347802988786513451486411409887164516065062084917556120712465074206435831498113605
8786437178698940322877889807009957616777351844979869726962356553244050911283984280960665761649310895230455072977431415102053987735969326553978994853162483051544656873294555116009995592043183070208706258164840540599577072097104139505857517663273929851202628854185356185647194933800084230503413037858893307713037149307477830536758283681093517617820169181420796105338681582230788318108428132051793761014952837330456262272828627355701464740578197966332613127307037255647286823496355917642353327912440019621838870388091824748629637425759125214639885130163183752378908729773517053259212525494555880921052679512582051516604297098204363525081039382358483926727008679327719083138865969291911863630382097160230960738043575559330264018212774424527719153248563876760067931499029384228993253862501939337758514377472011933279273181144830381169849387893799390755052093069179605579485710343655570028592595882436632426527654452895431758715126580164902410286422637215098476316042367916779431052267545769495994723721129943616294879642305545894912914632980455031755879087401575310699765408473606166727137934224515998416625122213056208800095077933103150699272650116151674702438463062734472714004926103668378506804002740045547964716693536349447660850580
205314962204511500352858372254132533167549960825498949618514841570703199264867431580754674275990554478140637041427842111391746883257447120035947621456863890934062044010795443059281736346976175772415034838334682726635263432655537852942177334888025283748611576171534251461847349566505628290587224150869640386437623371249743165260396675220683302142805646368906930575140628610003919131999295855501215111393294818218799982703289304596989070475000081175510085432290264502023736899104746316830742226946395027029820825791831870857382647221322734605026210073093918331247494307555600335550942340526536281372036612138713881098866303169425501998978400008829873080965592009371176208668290074288903681417933657472279670688597862835627506340169978450918788539270346340385928840299573889292189531738082166408734046381423516467694328971385421907314814283489322619386570046183556572383980777277173349209330683424343658179781015072259378576130442222984963071166207642585589822061597282467850868050737957726423713761694231879497037175627546427449730638216214828463003483408928375620315193290871300316930139260521382533279767663839278693750409419493280753368451508802658272220767624766390639285308433607255253282702383762149755935518922075584637512494819
271453634732502613378948161256470991260052778799128789839624515809143527363206813219580098196957510291648493698144497567392065251244844074992734669490296293997386198359280316655904691639367482203210051809125904410431506925238374843856343243276508280641059690938930957474434518308646618959004216831130099873532714372402117796666560677624822509159287675432413016478948594640872091688482149004426363946048517480052906306290126242866034249478040406351940088231081456109195799442996799641647167552689564613346415247906852055588498305665928450828756152103096629274760601528737639415361467941349982213641454967962723875032638267311935042334584913897338553953961877439389588793074211502597238465542889335363559052368180212013206172712561221352833891640659020253527584706465205486408990762759230842192028381048563437724528409174790022752557512795782713125166158329880702730769957185428522011430144840232256419113631679343171680631630775266488738173707357123139368825087043785842169049943237537188129367275730984789479909103397937113837824575137021012333461552176687570010445744268373840742899299977372834041925102853718964831225250407279578465008537542659673685686242773379131904890865110699190451534445434533919127658976874721029586168106207
```

## WP
### 原理（共模攻击）
e1与e2使用的相同的N进行对应的计算，若是e1与e2互质，则可以有贝祖等式得到s1与s2，实现$e_1*s_1+e_2*s_2 = 1$，通过得到两个s1与s2即可通过两个密文得到明文信息，在对其进行base64转码。

### code
```python
import base64

from Crypto.Util.number import long_to_bytes

def solve_stego(rsa_output):
    print("[*] 检测到 Base64 隐写，开始提取...")
    # 1. 按行分割
    lines = rsa_output.strip().split(b'\n')
    bin_str = ""
    base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    for line in lines:
        line = line.strip()
        if not line: continue
        # 转换为字符串处理

        s = line.decode()

        # 2. 判断 Padding 数量，提取隐写位

        if s.endswith("=="):

            # 2个等号，说明最后剩 1 个字节 (8bit)，编码成 2 个字符 (12bit)

            # 也就意味着隐写了 12 - 8 = 4 bit

            last_char = s[-3] # 倒数第三个字符是最后一个有效编码字符 (== 是最后两个)

            # 查找该字符在 Base64 表中的索引

            char_idx = base64_chars.index(last_char)

            # 取低 4 位

            bits = f"{char_idx:06b}"[-4:]

            bin_str += bits

        elif s.endswith("="):

            # 1个等号，说明最后剩 2 个字节 (16bit)，编码成 3 个字符 (18bit)

            # 也就意味着隐写了 18 - 16 = 2 bit

            last_char = s[-2] # 倒数第二个字符

            char_idx = base64_chars.index(last_char)

            # 取低 2 位

            bits = f"{char_idx:06b}"[-2:]

            bin_str += bits

    # 3. 将提取出的二进制串转换为字符

    print(f"[*] 提取到的二进制位长度: {len(bin_str)}")

    flag_bytes = b""

    for i in range(0, len(bin_str), 8):

        byte_chunk = bin_str[i:i+8]

        if len(byte_chunk) == 8:

            flag_bytes += bytes([int(byte_chunk, 2)])

    print("-" * 30)

    print("HIDDEN FLAG:")

    print(flag_bytes.decode(errors='ignore'))

    print("-" * 30)

  
  

def solve():

    print("[*] 正在读取 HUB1 和 HUB2...")

    # 读取文件逻辑（保持不变）

    try:

        with open("HUB1", "r") as f:

            content1 = f.read().split()

            N = Integer(content1[0])

            e1 = Integer(content1[1])

            c1_list = [Integer(x) for x in content1[2:] if x.strip()]

  

        with open("HUB2", "r") as f:

            content2 = f.read().split()

            e2 = Integer(content2[1])

            c2_list = [Integer(x) for x in content2[2:] if x.strip()]

    except Exception as e:

        print(f"[-] 读取文件出错: {e}")

        return

  

    # 检查互质

    g, s1, s2 = xgcd(e1, e2)

    if g != 1:

        print("[-] e1 和 e2 不互质，攻击无法进行！")

        return

  

    print("[*] 开始解密...")

    rsa_recovered_bytes = b""

  

    # 逐块解密

    for c1, c2 in zip(c1_list, c2_list):

        v1 = power_mod(c1, s1, N)

        v2 = power_mod(c2, s2, N)

        m = (v1 * v2) % N

  

        chunk = long_to_bytes(m)

        rsa_recovered_bytes += chunk

  
  

    print("\n" + "-"*30)

    print("【调试信息】RSA 解密结果前 100 个字符：")

    print("-"*30)

    # 打印原始字节的十六进制表示，看看是不是乱码

    print(f"Hex: {rsa_recovered_bytes[:20].hex()} ...")

    solve_stego(rsa_recovered_bytes)

    # 尝试作为文本打印，看看是不是像 Base64 (A-Z, a-z, 0-9, +, /)

    try:

        preview = rsa_recovered_bytes[:100].decode('ascii')

        print(f"Text: {preview}")

        # 简单的启发式检查

        import re

        if re.match(r'^[A-Za-z0-9+/=\s]+$', preview):

            print("==> 看起来像是有效的 Base64 字符串！")

        else:

            print("==> 警告：包含非 Base64 字符，RSA 解密可能出错了！")

    except UnicodeDecodeError:

        print("==> 警告：无法解码为 ASCII，说明解密结果是二进制乱码！")

  

    # ==========================================

    # 尝试 Base64 解码

    # ==========================================

    print("\n[*] 正在尝试 Base64 解码...")

    try:

        # 在 Python 3 中，b64decode 对于错误的 padding 极其敏感

        # 这是一个常见的 trick：手动补全 padding

        missing_padding = len(rsa_recovered_bytes) % 4

        if missing_padding:

            rsa_recovered_bytes += b'=' * (4 - missing_padding)

        final_flag = base64.b64decode(rsa_recovered_bytes)

        print("\n" + "="*30)

        print("FINAL FLAG:")

        # 尝试 decode 为 utf-8 显示，如果不行直接显示 bytes

        try:

            print(final_flag.decode())

        except:

            print(final_flag)

        print("="*30)

    except Exception as e:

        print(f"[-] Base64 解码最终失败: {e}")

        print("建议检查上面打印的【调试信息】，如果是乱码，说明共模攻击本身算错了。")

  

solve()
```

# 4.BabyRSA
## WP
### 题目
```
p+q : 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea
(p+1)(q+1) : 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740
e : 0xe6b1bee47bd63f615c7d0a43c529d219
d : 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5
enc_flag : 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a

```
### 原理
通过p+q与(p+1)(q+1)可以直接得到N = (p+1)(q+1)-(p+q) - 1，然后利用私钥直接解密。然后将得到的明文，转为bytes

## code
```python
from Crypto.Util.number import long_to_bytes

  

# 1. 输入题目给出的十六进制数据

# 注意：直接作为字符串传入，用 int(x, 16) 转换

sum_pq_hex = "0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea"

prod_plus1_hex = "0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740"

  

e_hex = "0xe6b1bee47bd63f615c7d0a43c529d219"

d_hex = "0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5"

enc_flag_hex = "0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a"

  


sum_pq = int(sum_pq_hex, 16)

prod_plus1 = int(prod_plus1_hex, 16)

d = int(d_hex, 16)

c = int(enc_flag_hex, 16)

  



N = prod_plus1 - sum_pq - 1

print(f"[*] Recovered N: {N}")

  

# 4. 直接解密

# m = c^d mod N

m = pow(c, d, N)

  

# 5. 转换为字符并打印

flag = long_to_bytes(m)

print(f"[+] Flag: {flag.decode()}")
```

```python
flag{cc7490e-78ab-11e9-b422-8ba97e5da1fd}
```


#  5. bbbbbbrsa
## 题目
```
p = 177077389675257695042507998165006460849
n = 37421829509887796274897162249367329400988647145613325367337968063341372726061
c = ==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM
```

```
from base64 import b64encode as b32encode

from gmpy2 import invert,gcd,iroot

from Crypto.Util.number import *

from binascii import a2b_hex,b2a_hex

import random

  

flag = "******************************"

  

nbit = 128

  

p = getPrime(nbit)

q = getPrime(nbit)

n = p*q

  

print p

print n

  

phi = (p-1)*(q-1)

  

e = random.randint(50000,70000)

  

while True:

    if gcd(e,phi) == 1:

        break;

    else:

        e -= 1;

  

c = pow(int(b2a_hex(flag),16),e,n)

  

print b32encode(str(c))[::-1]

  

# 2373740699529364991763589324200093466206785561836101840381622237225512234632
```

## WP 
### 理论
>题目给出了p与n，求得q,然后计算$\phi(n)$
>根据题目的python代码的 `e = random.randint(50000,70000)
>可知e是一个50000-70000中间一个与$\phi(n)$互质的随机数
>可以循环对于e进行测试，解密c
>c是进行了base64编码，然后逆置
>可以循环判断并解密c得到c的bytes
>判断是否有flag在里面，可以得到结果。

### code
```python
import base64
from Crypto.Util.number import long_to_bytes, inverse

p = 177077389675257695042507998165006460849
n = 37421829509887796274897162249367329400988647145613325367337968063341372726061

c_str_reversed = "==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM"

# 2. 计算 q 和 phi

q = n // p

phi = (p - 1) * (q - 1)

  

# 3. 还原密文 c (整数)

# 第一步：字符串逆序

c_str_b64 = c_str_reversed[::-1]

# 第二步：Base64 解码 (注意题目虽然叫 b32encode 但实际是 imports b64encode)

  

c_int_str = base64.b64decode(c_str_b64)

# 第三步：转为整数

c = int(c_int_str)

  

print(f"[*] Recovered c: {c}")

  

# 4. 爆破 e 并解密

print("[*] Brute forcing e...")

  

# e 的范围在 50000 到 70000 之间

for e_guess in range(50000, 70001):

    # e 必须与 phi 互质

    if e_guess % 2 == 0: # 简单的优化，phi通常是偶数，e通常是奇数

        continue

    try:

        # 尝试计算私钥 d

        # 如果 e_guess 和 phi 不互质，inverse 会报错，所以用 try-except

        d = inverse(e_guess, phi)

        # 尝试解密 m = c^d mod n

        m = pow(c, d, n)

        # 将明文整数转换为字节流

        flag_bytes = long_to_bytes(m)

        # 检查是否包含 flag 特征

        if b"flag" in flag_bytes:

            print(f"\n[+] Found e: {e_guess}")

            print(f"[+] Flag: {flag_bytes.decode()}")

            print(f"{flag_bytes}")

            print(f"{flag_bytes.hex()}")

            break

    except Exception:

        continue
```


# 6. basic rsa
## 题目
```python
import gmpy2
from Crypto.Util.number import *
from binascii import a2b_hex,b2a_hex

flag = "*****************"
p = 262248800182277040650192055439906580479
q = 262854994239322828547925595487519915551
e = 65533
n = p*q
c = pow(int(b2a_hex(flag),16),e,n)

print c

# 27565231154623519221597938803435789010285480123476977081867877272451638645710
```

## WP
东西都给了，直接解密，转Bytes
```python
from Crypto.Util.number import long_to_bytes, inverse

  

c = 27565231154623519221597938803435789010285480123476977081867877272451638645710

p = 262248800182277040650192055439906580479

q = 262854994239322828547925595487519915551

e = 65533

phi = (p - 1) * (q - 1)

d = inverse(e, phi)

m = pow(c, d, p * q)

flag = long_to_bytes(m)

print(flag.decode())
```

# 7.  ez_RSA
## 题目
```python
from Crypto.Util.number import *

from secret import flag

  

num1 = getPrime(512)

num2 = getPrime(512)

while num1<num2 :

    num2 = getPrime(512)

ring = RealField(1050)

num3 = ring(num1) /ring(num2)

  

print("num3=",num3)

p = getPrime(512)

q = getPrime(512)

n=p*q

e=65537

m = bytes_to_long(flag)

c=pow(m,e,n)

  

print("n=",n)

print("c=",c)

  

n2 = getPrime(512) * getPrime(512)

e1 = randint(1000,2000)

e2 = randint(1000,2000)

c1 = pow(p+num1,e1,n2)

c2 = pow(p+num2,e2,n2)

  

q1 = getPrime(512)

leak1 = pow(q+q1,2024,n)

leak2 = pow(q1+2024,q,n)

  
  

print("n2=",n2)

print("e1=",e1)

print("e2=",e2)

print("c1=",c1)

print("c2=",c2)

print("leak1=",leak1)

print("leak2=",leak2)

  
  
  

"""

num3= 1.36557212221826657073387899060669771982679822943621690677450888408226656788387273887547841291114809989272635809810564202247340711087479554863446719786359395466961253205133910506682801159622545780721946115442033391600881399634390008053822158098121985270501317972263356522400827768601773721146954464269212959784543085

n= 85105083975491693151454182116844944807066048677068373328227644321539783064315677834754866742549592569194223084173286381150626593510265361114796714226058887906219454795525438819082646860141163940340082006344850825956811992304447978369108606993344902286569100146695092703383844402883938506877787042873586279543

c= 8090472119640930864901421058741085326954308673260202542020919764880488559370287585797498390920330336595858609617432370825503480936376306766495089200286004922821787548265246289552343468177624634434613746605553770994437785042510225956023382347023663125411103947669109085411939772215657220674436476279268458980

n2= 101642316595332652021348165259853423287787139517550249986161819826180514401858258316466101056877182367161299111697465439636861942636526396547011727147471566130633614685728563576613692851860684686033186826342178072882901576159305747639645374751566751967096281105148714033096611618024355982220235949274576036321

e1= 1630

e2= 1866

c1= 8857135083997055103287497833179378469532619748945804429057682575070405217145941944821968708809563240261403711644389684947851643865895254406194464015430673347359589677809515117412321862622147634752091324365628790687343748145339949310696116239361890881096088375070083053010564890401663562726144984405628773323

c2= 44531030636557714647477473185500183066851251320453194953972504422367649302810396344051696851757189817391648356459225688318373454949578822468293099948132700460437006478679492801335689493431764882835346904225119630026545592437198370606462285405519745361570058335573353886454277790277663038008240372746639859253

leak1= 82301473255013183706458389946960254392188270550712533886416705365418418731488346328643954589202172816597173052792573628245245948345810581701878535280775967863966009605872386693838526935762655380705962833467046779524956212498594045378770790026387120339093736625186401934354434702063802537686761251873173518029

leak2= 43580171648136008789232340619597144591536098696024883687397347933098380327258730482377138309020375265135558484586783368757872008322883985094403855691297725907800406097129735499961231236473313141257901326737291586051506797429883866846199683028143924054925109557329949641367848264351523500925115860458645738192

  

"""
```


## WP
### 理论
**题目数据关系**
>已知：num3,e1,e2,n,c,n2,c1,c2,leak1,leak2
>__数据关系__:
> 	$num3 = num1/num2$ 
> 	$n = p*q$
> 	$c_1 = (p+num1)^{e_1} \ mod \ n_2$
> 	$c_2 = (p+num2)^{e_2}\ mod \ n_2$
> 	$leak1 = (q+q1)^{2024}\ mod \ n$
> 	$leak2 = (q1+2024)^q\ mod \ n$

**解题思路**
>1. 由`ring = RealField(1050)`高精度计算num3，可以通过连分数得到原来的`num1`与`num2`.
>2. 获得`num1,num2`之后，带入`c1,c2`
>3. 在`mod n2`的条件下，构造两个函数，那么两个函数的最大公约多项式，就是`x-p`，即最终的解。
>	1. $f1 = (x+num1)^{e_1}-c1$
>	2. $f_2 = (x+num2)^{e_2}-c2$
>4. 对`f1`与`f2`求最大公约数，求出解`p`的数值。
>5. 然后就可以进行常规解密了。

### code
```python
import binascii
from Crypto.Util.number import long_to_bytes

def solve():
    num3_val = 1.36557212221826657073387899060669771982679822943621690677450888408226656788387273887547841291114809989272635809810564202247340711087479554863446719786359395466961253205133910506682801159622545780721946115442033391600881399634390008053822158098121985270501317972263356522400827768601773721146954464269212959784543085
    n_val = 85105083975491693151454182116844944807066048677068373328227644321539783064315677834754866742549592569194223084173286381150626593510265361114796714226058887906219454795525438819082646860141163940340082006344850825956811992304447978369108606993344902286569100146695092703383844402883938506877787042873586279543
    c_val = 8090472119640930864901421058741085326954308673260202542020919764880488559370287585797498390920330336595858609617432370825503480936376306766495089200286004922821787548265246289552343468177624634434613746605553770994437785042510225956023382347023663125411103947669109085411939772215657220674436476279268458980
    n2_val = 101642316595332652021348165259853423287787139517550249986161819826180514401858258316466101056877182367161299111697465439636861942636526396547011727147471566130633614685728563576613692851860684686033186826342178072882901576159305747639645374751566751967096281105148714033096611618024355982220235949274576036321
    e1_val = 1630
    e2_val = 1866
    c1_val = 8857135083997055103287497833179378469532619748945804429057682575070405217145941944821968708809563240261403711644389684947851643865895254406194464015430673347359589677809515117412321862622147634752091324365628790687343748145339949310696116239361890881096088375070083053010564890401663562726144984405628773323

    c2_val = 44531030636557714647477473185500183066851251320453194953972504422367649302810396344051696851757189817391648356459225688318373454949578822468293099948132700460437006478679492801335689493431764882835346904225119630026545592437198370606462285405519745361570058335573353886454277790277663038008240372746639859253
    # 连分数还原
  
    # 使用高精度实数域
    ring = RealField(1050)
    num3 = ring(num3_val)
    # 连分数展开
    cf = continued_fraction(num3)

    num1 = 0
    num2 = 0
  
    for convergent in cf.convergents():
        numerator = convergent.numerator()
        denominator = convergent.denominator()
        # num1 和 num2 都是 512 位
        if numerator.nbits() == 512 and denominator.nbits() == 512:
            num1 = int(numerator)
            num2 = int(denominator)
            print(f"    Found num1: {num1}")
            print(f"    Found num2: {num2}")
            break
    if num1 == 0:
        print("[-] Failed to recover num1/num2")

        return

  

    #  多项式 GCD 恢复 p

    print("[+] Stage 2: Recovering p via Custom Polynomial GCD...")

    # 定义模 n2 的多项式环
    R.<x> = PolynomialRing(Zmod(n2_val))

    # 构造两个多项式: (x + num1)^e1 - c1 = 0
    f1 = (x + num1)^e1_val - c1_val
    f2 = (x + num2)^e2_val - c2_val

    # --- 自定义 GCD 函数 (解决 NotImplementedError) ---

    def pgcd(a, b):

        while b:

            a, b = b, a % b

            # 将多项式首项系数归一化 (Monic)，防止系数膨胀
            if b:
                b = b.monic()
        return a.monic()

    # -----------------------------------------------

  

    # 计算 GCD

    g = pgcd(f1, f2)

    # g 应该是 x + p 或者 x - p 的形式

    # 提取常数项，取负数得到 p

    p_recovered = int(-g.constant_coefficient())

    print(f"    Recovered p: {p_recovered}")
    # 简单验证

    if n_val % p_recovered == 0:

        print("    [Success] p is correct.")

    else:

        print("    [Fail] p is incorrect.")

        return

  

    #  Stage 3: RSA 解密 
    p = p_recovered
    q = n_val // p
    phi = (p - 1) * (q - 1)
    e = 65537
    # 求私钥 d
    d = inverse_mod(e, phi)
    # 解密 m
    m = power_mod(c_val, d, n_val)
    # 转换为 Flag
    try:
        flag = long_to_bytes(int(m))
        print("\n" + "="*50)
        print(f"FLAG: {flag.decode()}")
        print("="*50 + "\n")
    except Exception as e:
        print(f"[-] Decryption failed: {e}")

# 执行主函数

solve()
```



# 8. RoarCTF2019 RSA
## 题目
```python
A=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x
p=next_prime(z*x*y)
q=next_prime(z)
A =  2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724
n =  117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127
c =  41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128
```

## WP
### 理论与思路
- 观察 $A$ 的构成：
    $$A = \dots + y^{316} + \frac{y+1}{x}$$
- **估算位长**：
    - 题目给出的 $A$ 长度约为 2048 bit（约 618 位十进制）。
    - 若 $y^{316} \approx A$，则 $316 \cdot \log_{10} y \approx 618$。
    - 推算出 $\log_{10} y \approx 1.95$，即 **$y \approx 90$**。
    - **结论**：$y$ 是一个极小的整数。
- **确定 $y$**：直接对 $A$ 开 316 次方取整，得到 $y$。
- **确定 $x$**：
    - 因为 $y$ 很小（约 90），且 $(y+1)/x$ 是整数。
    - 所以 $x$ 必然是 $y+1$ 的因子。
    - $y+1$ 的因子很少，可以直接遍历验证，找到满足等式的 $x$。
- **确定 $z, p, q$**：
    - 已知 $p \approx zxy, q \approx z$。
    - 则 $n = pq \approx z^2xy$。
    - 推导出 $z \approx \sqrt{\frac{n}{xy}}$。
    - 求出 $z$ 后，`next_prime(z)` 即为 $q$。
- **解密**：常规 RSA 解密。

### code
```python
import gmpy2
from Crypto.Util.number import long_to_bytes

  

def solve():

    # ================= 数据输入 =================

    A_val = 2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724

    n_val = 117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127

    c_val = 41971850275428383625653350824107291609587853887037624239544762751558838294718672159979929266922528917912189124713273673948051464226519605803745171340724343705832198554680196798623263806617998072496026019940476324971696928551159371970207365741517064295956376809297272541800647747885170905737868568000101029143923792003486793278197051326716680212726111099439262589341050943913401067673851885114314709706016622157285023272496793595281054074260451116213815934843317894898883215362289599366101018081513215120728297131352439066930452281829446586562062242527329672575620261776042653626411730955819001674118193293313612128

    A = gmpy2.mpz(A_val)

    n = gmpy2.mpz(n_val)

    c = gmpy2.mpz(c_val)

  

    # 1. 计算 y

    # y 约为 A 的 316 次方根

    y_approx, _ = gmpy2.iroot(A, 316)

    y = int(y_approx)

    print(f"[+] Found potential y: {y}")

    # 2. 爆破 x

    # x 必须整除 y+1

    target_num = y + 1

    factors = []

    # 找因子

    for i in range(1, int(target_num**0.5) + 1):

        if target_num % i == 0:

            factors.append(i)

            factors.append(target_num // i)

    real_x = None

    print(f"[*] Checking {len(factors)} candidates for x...")

    for x_cand in factors:

        if x_cand == 0: continue

        # 代入公式验证 A

        # A = (((y%x)**5)%(x%y))**2019 + y**316 + (y+1)/x

        try:

            term1_base = (pow(y % x_cand, 5)) % (x_cand % y)

            term1 = pow(term1_base, 2019)

            term2 = pow(y, 316)

            term3 = (y + 1) // x_cand

            calc_A = term1 + term2 + term3

            if calc_A == A:

                real_x = x_cand

                print(f"[+] Found correct x: {real_x}")

                break

        except ZeroDivisionError:

            continue

    if real_x is None:

        print("[-] Failed to find x.")

        return

  

    # 3. 求解 z 和 p, q

    # n ≈ z^2 * x * y

    # z ≈ sqrt(n / (x*y))

    product_xy = real_x * y

    z_approx = gmpy2.isqrt(n // product_xy)

    # q 是 z 的下一个素数

    q = gmpy2.next_prime(z_approx)

    if n % q == 0:

        p = n // q

        print("[+] Factorization Successful!")

        print(f"    p: {p}")

        print(f"    q: {q}")

    else:

        # 也许 q 是 z 之前的素数？或者 z 估算偏差？

        # 尝试微调

        print("[-] Direct factorization failed, searching near z...")

        # (通常 next_prime 就够了，除非 z_approx 偏大)

        return

  

    # 4. RSA 解密

    phi = (p - 1) * (q - 1)

    e = 65537

    d = gmpy2.invert(e, phi)

    m = pow(c, d, n)

    print(f"[+] Flag: {long_to_bytes(m).decode()}")

  

if __name__ == '__main__':

    solve()
```

# 9. RoarCTF2019 babyRSA

## 题目
```python
import sympy

import random

  

def myGetPrime():

    A= getPrime(513)

    print(A)

    B=A-random.randint(1e3,1e5)

    print(B)

    return sympy.nextPrime((B!)%A)

p=myGetPrime()

#A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407

#B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596

  

q=myGetPrime()

#A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927

#B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026

  

r=myGetPrime()

  

n=p*q*r

#n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733

c=pow(flag,e,n)

#e=0x1001

#c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428

#so,what is the flag?
```

## WP
### 理论与思路
#### 核心逻辑

题目定义了一个函数 `myGetPrime()`，其生成素数的逻辑如下：
1. 生成一个 513 位的随机素数 $A$。
2. 生成一个数 $B$，其中 $B = A - \text{random}(1000, 100000)$。这意味着 $B$ 非常接近 $A$，且 $B < A$。
3. 计算 $X = (B!) \pmod A$。
4. 返回 $X$ 的下一个素数作为结果（即 $p$ 或 $q$）。

拿到 $A$ 和 $B$ 的值（对于 $p$ 和 $q$），但没有拿到 $r$ 的生成参数。需要利用 $A$ 和 $B$ 恢复 $p$ 和 $q$，进而求出 $r$，最后解密 RSA。
- **恢复 $p$**：利用 $A_1, B_1$，计算 $k_1 = A_1 - 1 - B_1$。计算 $X_1 = B_1! \pmod{A_1}$，然后 $p = \text{next\_prime}(X_1)$。
- **恢复 $q$**：利用 $A_2, B_2$，同理计算出 $q$。
- **恢复 $r$**：已知 $n = p \times q \times r$，则 $r = n // (p \times q)$。
- **解密**：计算 $\phi(n) = (p-1)(q-1)(r-1)$，求私钥 $d$，解密 $c$ 得到 flag。
### code
```python
import gmpy2
from Crypto.Util.number import long_to_bytes
A1 = 21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407
B1 = 21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596
A2 = 16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927
B2 = 16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026
n = 85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733
e = 0x1001
c = 75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428

def recover_prime(A, B):
    # 威尔逊定理逆向
    # k = A - 1 - B
    # B! = - ((-1)^k * k!)^-1 mod A

    k = A - 1 - B

    # 计算 k! mod A

    # 由于 k 较小 (~10^5)，直接循环乘

    fact_k = 1

    for i in range(1, k + 1):

        fact_k = (fact_k * i) % A

    # 计算 B! mod A

    # 如果 k 是奇数， (-1)^k = -1，公式变为 B! = -(-fact_k)^-1 = (fact_k)^-1

    # 如果 k 是偶数， (-1)^k = 1，公式变为 B! = -(fact_k)^-1

    inv_fact = gmpy2.invert(fact_k, A)

    if k % 2 == 1:

        val = inv_fact

    else:

        val = -inv_fact % A

    # 恢复 p 或 q，即 next_prime(val)

    return gmpy2.next_prime(val)

  

# 1. 恢复 p 和 q


p = recover_prime(A1, B1)

print(f"[+] p = {p}")

  


q = recover_prime(A2, B2)

print(f"[+] q = {q}")

  

# 2. 恢复 r

print("[*] Recovering r...")

r = n // (p * q)

# 验证一下

assert n == p * q * r

print(f"[+] r = {r}")


# 3. 解密


phi = (p - 1) * (q - 1) * (r - 1)

d = gmpy2.invert(e, phi)

m = pow(c, d, n)

  

flag = long_to_bytes(m)

print(f"\n[+] Flag: {flag.decode()}")
```

# 9. GWCTF 2019BabyRSA

## WP
### 理论
- **RSA参数生成漏洞**：当 $p$ 和 $q$ 非常接近（Consecutive Primes）时，可以直接对 $N$ 开方进行分解。
- **代数方程求解**：利用 $x+y$ 和 $x^3+y^3$ 求解 $x$ 和 $y$。
#### 1. 题目分析与漏洞利用

漏洞点：
代码中生成素数的方式如下：

```Python
p = sympy.nextprime(secret_num)
q = sympy.nextprime(p)
N = p * q
```
这意味着 $q$ 是 $p$ 之后的下一个素数。因此，$p$ 和 $q$ 的数值非常接近。
根据数学原理，如果 $p \approx q$，那么 $N = p \times q \approx p^2$。这意味着 $\sqrt{N}$ 将非常接近 $p$。
具体来说，由于 $p < q$，所以 $p < \sqrt{N} < q$。我们可以计算 $\lfloor \sqrt{N} \rfloor$，然后向下寻找第一个能整除 $N$ 的数，那个数就是 $p$。
RSA解密：
得到 $p$ 和 $q$ 后，我们可以计算欧拉函数 $\phi(N) = (p-1)(q-1)$ 和私钥 $d = e^{-1} \pmod{\phi(N)}$。
题目给出了两个密文 $m_1$ 和 $m_2$，分别是 $c_1$ 和 $c_2$ 加密后的结果。利用私钥 $d$ 对其解密
- $C_1 = m_1^d \pmod N$
- $C_2 = m_2^d \pmod N$
    由于题目中使用了 assert(c2 < N)，这意味着原始的 $c_1$ 和 $c_2$ 没有发生模 $N$ 溢出，所以解密出的 $C_1$ 就是 $c_1$，$C_2$ 就是 $c_2$。

#### 2. 代数方程求解
有以下已知量：
- $x + y = c_1$ （其中 $x$ 是 flag1 的整数值，$y$ 是 flag2 的整数值）
- $x^3 + y^3 = c_2$
求 $x$ 和 $y$。利用立方和公式：
$$x^3 + y^3 = (x+y)(x^2 - xy + y^2)$$
$$x^3 + y^3 = (x+y)((x+y)^2 - 3xy)$$

将已知量代入：

$$c_2 = c_1 \cdot (c_1^2 - 3xy)$$

求出 $x$ 和 $y$ 的积 $P = xy$：

$$c_2 / c_1 = c_1^2 - 3P$$

$$3P = c_1^2 - c_2/c_1$$

$$P = \frac{c_1^2 - c_2/c_1}{3}$$

现在知道和 $S = x+y = c_1$ 以及积 $P = xy$。根据韦达定理，$x$ 和 $y$ 是一元二次方程 $Z^2 - S \cdot Z + P = 0$ 的两个根。

利用求根公式：

$$Z = \frac{S \pm \sqrt{S^2 - 4P}}{2}$$

解出的两个根转为字符串即为 flag 的两部分。

### code
```python
import gmpy2
from Crypto.Util.number import long_to_bytes

# ================= 题目数据 =================
N = 636585149594574746909030160182690866222909256464847291783000651837227921337237899651287943597773270944384034858925295744880727101606841413640006527614873110651410155893776548737823152943797884729130149758279127430044739254000426610922834573094957082589539445610828279428814524313491262061930512829074466232633130599104490893572093943832740301809630847541592548921200288222432789208650949937638303429456468889100192613859073752923812454212239908948930178355331390933536771065791817643978763045030833712326162883810638120029378337092938662174119747687899484603628344079493556601422498405360731958162719296160584042671057160241284852522913676264596201906163
m1 = 90009974341452243216986938028371257528604943208941176518717463554774967878152694586469377765296113165659498726012712288670458884373971419842750929287658640266219686646956929872115782173093979742958745121671928568709468526098715927189829600497283118051641107305128852697032053368115181216069626606165503465125725204875578701237789292966211824002761481815276666236869005129138862782476859103086726091860497614883282949955023222414333243193268564781621699870412557822404381213804026685831221430728290755597819259339616650158674713248841654338515199405532003173732520457813901170264713085107077001478083341339002069870585378257051150217511755761491021553239
m2 = 487443985757405173426628188375657117604235507936967522993257972108872283698305238454465723214226871414276788912058186197039821242912736742824080627680971802511206914394672159240206910735850651999316100014691067295708138639363203596244693995562780286637116394738250774129759021080197323724805414668042318806010652814405078769738548913675466181551005527065309515364950610137206393257148357659666687091662749848560225453826362271704292692847596339533229088038820532086109421158575841077601268713175097874083536249006018948789413238783922845633494023608865256071962856581229890043896939025613600564283391329331452199062858930374565991634191495137939574539546

# 关键修正：题目给的是 0x10001 (65537)
e = 65537

# 1. 费马分解 (Close Primes)
# 既然 p, q 是连续素数，从 isqrt(N) 向下找即可
print("[*] Factoring N...")
p = gmpy2.isqrt(N)
while N % p != 0:
    p -= 1
q = N // p
print(f"[+] Found p: {p}")

# 2. RSA 解密
print("[*] Decrypting...")
phi = (p - 1) * (q - 1)
d = gmpy2.invert(e, phi)

# m1 对应 c1 (和), m2 对应 c2 (立方和)
c1 = pow(m1, d, N)
c2 = pow(m2, d, N)

print(f"[+] Decrypted sum (c1): {c1}")
print(f"[+] Decrypted cube sum (c2): {c2}")

# 3. 解方程组
# c1 = x + y
# c2 = x^3 + y^3
# 韦达定理构造方程: Z^2 - S*Z + P = 0
S = c1
# P = (c1^2 - c2/c1) / 3
P = (c1**2 - (c2 // c1)) // 3

delta = S**2 - 4*P

if delta < 0:
    print("[-] Error: Delta is negative. Check decryption parameters.")
else:
    sqrt_delta = gmpy2.isqrt(delta)
    F1 = (S + sqrt_delta) // 2
    F2 = (S - sqrt_delta) // 2
    
    # 4. 拼接 Flag
    flag_part1 = long_to_bytes(F1)
    flag_part2 = long_to_bytes(F2)
    
    # 根据题目格式 "GWHT{" 判断顺序
    if flag_part1.startswith(b'GWHT'):
        flag = flag_part1 + flag_part2
    else:
        flag = flag_part2 + flag_part1
        
    print(f"\n[+] Flag: {flag.decode()}")
```

# 10.NCTF2019childRSA
## 题目
```python
from random import choice

from Crypto.Util.number import isPrime, sieve_base as primes

from flag import flag

  
  

def getPrime(bits):

    while True:

        n = 2

        while n.bit_length() < bits:

            n *= choice(primes)

        if isPrime(n + 1):

            return n + 1

  

e = 0x10001

m = int.from_bytes(flag.encode(), 'big')

p, q = [getPrime(2048) for _ in range(2)]

n = p * q

c = pow(m, e, n)

  

# n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513

# c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108
```

## WP
### 理论
**原理简述**： 根据费马小定理，如果 $p$ 是素数，且 $a$ 与 $p$ 互质，则 $a^{p-1} \equiv 1 \pmod p$。 如果 $p-1$ 是光滑的，我们取一个包含所有小素数因子的数 $K$（例如 $B!$ 或者 $\text{LCM}(1, \dots, B)$），那么 $p-1$ 很有可能是 $K$ 的因子。 此时计算 $M = \text{gcd}(a^K - 1, N)$，如果 $p-1 | K$，那么 $a^K \equiv 1 \pmod p$，这意味着 $a^K - 1$ 是 $p$ 的倍数。因此 GCD 计算能将 $p$ 提取出来。
### code
```python
from Crypto.Util.number import *

def Pollard_p_1(N):
    a = 2
    while True:
        f = a
        # precompute
        for n in range(1, 80000):
            f = pow(f, n, N)
        for n in range(80000, 104729+1):
            f = pow(f, n, N)
            if n % 15 == 0:
                d = GCD(f-1, N)
                if 1 < d < N:
                    return d
        print(a)
        a += 1
```

```python
from Crypto.Util.number import *

n = 1592519204764870135...
c = 5744608257563538066...
p = 5075332621067110585...
q = n // p
assert(p*q == n)

d = inverse(0x10001, (p-1)*(q-1))

m = pow(c, d, n)
print(long_to_bytes(m))
# b'NCTF{Th3r3_ar3_1ns3cure_RSA_m0duli_7hat_at_f1rst_gl4nce_appe4r_t0_be_s3cur3}'
```